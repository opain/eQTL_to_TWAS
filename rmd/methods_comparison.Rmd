---
title: "Comparison of Methods"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(knitr)
library(data.table)

```

***

# Introduction

Here, we will evaluate methods for deriving TWAS SNP-weights based on eQTL summary statistics.

There are two stages to this process:

1) Determining which genes to derive TWAS SNP-weights for
2) Derive SNP-weights predicting gene expression

***

## Determining which genes to derive TWAS SNP-weights for

Existing approaches:

- For SMR this is done by analysing any gene with a genome-wide significant eQTL
- For FUSION this is done by analysing any gene with cis-SNPh2 p < 0.01
- For MetaXcan this is done by analysing any gene with significant positive R2 using SNP-weights

The FUSION and MetaXcan approach is better for determining genes to include in a GWAS as it better reflects the power that TWAS would have. We may not always have a target sample to test the variance explained by the SNP-weights, so the MetaXcan approach is less applicable. So, I think we should use the same criteria as FUSION, except we must use a summary statistic based approach to estimate SNP-based heritability. We should compare summary statistic approaches to estimates from GREML as reported in FUSION released SNP-weights. The approach also needs to be fast as it will need to be implemented for each gene seperately.

***

## Derive SNP-weights predicting gene expression

SMR uses single eQTL summary statistics, making it applicable to a wider range of datasets and results from meta-analyses. TWAS based methods are not currently relevent when only eQTL summary statistics are available, as the advantage of these methods over SMR is their ability to incorporate the effects of multiple SNPs on gene expression. Currently, TWAS methods use SNP-weights derived using individual level data, which means TWAS cannot use meta-analysis results for eQTLs, and often TWAS weights are unavailable for the latest eQTL datasets. So, here we will compare a range of summary statistic approaches to derive TWAS weights. Again, the method will need to be fast since it will need to be applied to each genes seperately. Summary statistic based polygenic scoring methods will likely be of use, though given the lack of target samples for validation, a pseudovalidation approach will be necessary, which estimates the optimal parameters without a target sample for validation.

Possible methods for deriving SNP-weights:

- SBayesR
- DBSLMM
- PRScs auto
- Mega-PRS
- SuSiE

***

# Methods

***

## Preliminary analysis using GTEx v7

Comparison using GTEx v7 eQTL data and FUSION SNP-weights. Comparison to FUSION weights is not ideal as by chance different leads SNP could be selected. Ideally we would compare summary statistic-based and observed TWAS weights to observed expression. However, lets start with this as it will allow comparison of heritability estimates and be a good opportunity to design the study.

We will use whole blood data for the comparison. eQTL summary statistics are downloaded from [here](https://gtexportal.org/home/downloads/adult-gtex/qtl). FUSION TWAS SNP-weights were downloaded from [here](http://gusevlab.org/projects/fusion/weights/GTEx.Whole_Blood.P01.tar.bz2).

***

### Compare SNP-h2 estimates

We will compare different version of GCTB Bayes models and LDSC. If LDSC doesn't work, then LDAK model is unlikely to make a difference. To avoid unessecary compuational burden, only estimate hsq for 100 genes on chromosome 22.

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
# Download GTEx eQTL data
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7
wget https://storage.googleapis.com/adult-gtex/bulk-qtl/v7/single-tissue-cis-qtl/all_snp_gene_associations/Whole_Blood.allpairs.txt.gz
gunzip Whole_Blood.allpairs.txt.gz

# Create file just containing chromosome 22
chr=22
pattern=$(echo ^${chr}_)
awk -v pat="$pattern" '$2 ~ pat { print }' /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.txt > /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.chr${chr}.txt_tmp
cat <(head -n1 /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.txt) /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.chr${chr}.txt_tmp > /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.chr${chr}.txt
rm /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.chr${chr}.txt_tmp

# Delete full eQTL sumstats to save space
rm /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.txt

# Download the FUSION SNP weights for GTEx v7 whole blood
mkdir fusion
cd fusion
wget http://gusevlab.org/projects/fusion/weights/GTEx.Whole_Blood.ALL.tar.bz2
tar xjvf GTEx.Whole_Blood.ALL.tar.bz2

mv WEIGHTS/* ./
rm GTEx.Whole_Blood.ALL.tar.bz2
rm -r WEIGHTS

```

```{r, eval=F, echo=T}
# Use GenoPred analysis conda environment for running R
# conda activate /scratch/prj/oliverpainfel/Software/MyGit/GenoPred/pipeline/.snakemake/conda/aea4ef260655c3bcc12fec8909f5f6dd_
library(data.table)

# Make output directory
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesS')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/LDSC')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/RDat_files')

# Read in HapMap3 SNP-list
hm3_snp<-fread('/users/k1806347/oliverpainfel/Data/ldsc/w_hm3.snplist')

sbayesr_h2<-NULL
sbayesr_robust_h2<-NULL
sbayess_h2<-NULL
ldsc_h2<-NULL

# Run across each chromosome separately
for(chr_i in 22){
  # Read in eQTL data
  eqtl<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.chr',chr_i,'.txt'))
  
  # Create CHR, BP, A1, A2, and Build columns
  var_id<-data.table(do.call(rbind, strsplit(eqtl$variant_id, '_')))
  names(var_id)<-c('CHR','BP','A1','A2','Build')
  var_id$CHR<-as.numeric(var_id$CHR)
  var_id$BP<-as.numeric(var_id$BP)
  
  eqtl<-cbind(eqtl, var_id)
  
  # Insert IUPAC codes for SNPs
  eqtl$IUPAC[eqtl$A1 == 'A' & eqtl$A2 =='T' | eqtl$A1 == 'T' & eqtl$A2 =='A']<-'W'
  eqtl$IUPAC[eqtl$A1 == 'C' & eqtl$A2 =='G' | eqtl$A1 == 'G' & eqtl$A2 =='C']<-'S'
  eqtl$IUPAC[eqtl$A1 == 'A' & eqtl$A2 =='G' | eqtl$A1 == 'G' & eqtl$A2 =='A']<-'R'
  eqtl$IUPAC[eqtl$A1 == 'C' & eqtl$A2 =='T' | eqtl$A1 == 'T' & eqtl$A2 =='C']<-'Y'
  eqtl$IUPAC[eqtl$A1 == 'G' & eqtl$A2 =='T' | eqtl$A1 == 'T' & eqtl$A2 =='G']<-'K'
  eqtl$IUPAC[eqtl$A1 == 'A' & eqtl$A2 =='C' | eqtl$A1 == 'C' & eqtl$A2 =='A']<-'M'
  
  # Remove INDELS
  eqtl<-eqtl[!is.na(eqtl$IUPAC),]
  
  # Calculate N for each association
  eqtl$N<-round((eqtl$ma_count/eqtl$maf)/2,1)
  
  # Check the build
  table(eqtl$Build) 
  # They are all b37
  
  ###
  # Insert RSIDs
  ###
  
  # Read in 1KG reference SNP data
  # Use the 
  ref_bim_i<-fread(paste0('/users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/ref.chr',chr_i,'.bim'))
  names(ref_bim_i)<-c('CHR','SNP','POS','BP','A1','A2')
  
  # Extract hm3 SNPs
  ref_bim_i<-ref_bim_i[ref_bim_i$SNP %in% hm3_snp$SNP,]
  
  # Insert IUPAC codes
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'A' & ref_bim_i$A2 =='T' | ref_bim_i$A1 == 'T' & ref_bim_i$A2 =='A']<-'W'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'C' & ref_bim_i$A2 =='G' | ref_bim_i$A1 == 'G' & ref_bim_i$A2 =='C']<-'S'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'A' & ref_bim_i$A2 =='G' | ref_bim_i$A1 == 'G' & ref_bim_i$A2 =='A']<-'R'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'C' & ref_bim_i$A2 =='T' | ref_bim_i$A1 == 'T' & ref_bim_i$A2 =='C']<-'Y'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'G' & ref_bim_i$A2 =='T' | ref_bim_i$A1 == 'T' & ref_bim_i$A2 =='G']<-'K'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'A' & ref_bim_i$A2 =='C' | ref_bim_i$A1 == 'C' & ref_bim_i$A2 =='A']<-'M'

  # Merge target and reference based on position
  ref_target<-merge(eqtl, ref_bim_i, by=c('CHR','BP'))
  
  # I have used the GTEx reference data as well, and the same number is returned. 
  # Note: The A1 allele is the ref allele.
  # Small number of SNPs remaining highlights the limitation of using HapMap3 SNPs only.
  
  # Identify SNPs for which alleles need to be flipped
  flip_tmp<-ref_target[(ref_target$IUPAC.x == 'R' & ref_target$IUPAC.y == 'Y' | 
                          ref_target$IUPAC.x == 'Y' & ref_target$IUPAC.y == 'R' | 
                          ref_target$IUPAC.x == 'K' & ref_target$IUPAC.y == 'M' |
                          ref_target$IUPAC.x == 'M' & ref_target$IUPAC.y == 'K'),]
  
  # Idenitfy SNPs which match the reference alleles
  incl<-ref_target[ ref_target$IUPAC.x == 'R' & ref_target$IUPAC.y == 'R' | 
                      ref_target$IUPAC.x == 'Y' & ref_target$IUPAC.y == 'Y' | 
                      ref_target$IUPAC.x == 'K' & ref_target$IUPAC.y == 'K' |
                      ref_target$IUPAC.x == 'M' & ref_target$IUPAC.y == 'M' ]
  
  # If a SNP that needs to be flipped has a duplicate that is on the correct strand, remove it.
  flip<-flip_tmp[!(flip_tmp$SNP %in% incl$SNP)]
  
  # Flip alleles where necessary
  flip_tmp$A1_flipped<-flip_tmp$A1.x
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'A']<-'T'
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'T']<-'C'
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'G']<-'C'
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'C']<-'G'
  flip_tmp$A1.x<-flip_tmp$A1_flipped
  flip_tmp$A1_flipped<-NULL
  
  flip_tmp$A2_flipped<-flip_tmp$A2.x
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'A']<-'T'
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'T']<-'C'
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'G']<-'C'
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'C']<-'G'
  flip_tmp$A2.x<-flip_tmp$A2_flipped
  flip_tmp$A2_flipped<-NULL
  
  # Recombine and format
  eqtl_harm<-rbind(flip_tmp, incl)
  eqtl_harm<-eqtl_harm[,c('CHR','SNP','BP','A1.x','A2.x',"gene_id","variant_id","tss_distance","ma_samples","ma_count","maf","pval_nominal","slope","slope_se","N"), with=F]
  names(eqtl_harm)[names(eqtl_harm) == 'A1.x']<-'A1'
  names(eqtl_harm)[names(eqtl_harm) == 'A2.x']<-'A2'

  # Remove variants with MAF < 1%
  eqtl_harm<-eqtl_harm[eqtl_harm$maf >= 0.01,]
  
  eqtl<-eqtl_harm
  rm(eqtl_harm)
  
  # Identify unique genes 
  genes<-unique(eqtl$gene_id)
  
  # Subset the first 100 genes
  genes<-genes[1:100]

  # Run for each gene seperately
  for(gene_i in genes){
    print(which(genes == gene_i))

    eqtl_gene_i<-eqtl[eqtl$gene_id == gene_i,]
    
    #######
    # SBayesR
    #######
    
    # Format for SBayesR
    eqtl_gene_i_sbayesr<-eqtl_gene_i[,c('SNP','A1','A2','maf','slope','slope_se','pval_nominal','N'), with=F]
    names(eqtl_gene_i_sbayesr)<-c('SNP','A1','A2','freq','b','se','p','N')
    
    # write in SBayesR format
    fwrite(eqtl_gene_i_sbayesr, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.txt'), sep=' ', na = "NA", quote=F)
    
    # Run SBayesR
    log<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes R --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.95,0.02,0.02,0.01 --gamma 0.0,0.01,0.1,1 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.txt --chain-length 10000 --exclude-mhc --burn-in 2000 --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.SBayesR'), intern=T)
    
    # Run SBayesR
    log2<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes R --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.95,0.02,0.02,0.01 --gamma 0.0,0.01,0.1,1 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.txt --chain-length 10000 --robust --exclude-mhc --burn-in 2000 --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.SBayesR_robust'), intern=T)
    
    #######
    # SBayesS
    #######
    
    # Run SBayesS
    log3<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes S --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.1 --hsq 0.5 --chain-length 25000 --burn-in 5000 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.txt --exclude-mhc --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesS/',gene_i,'.SBayesS'), intern=T)
    
    #######
    # LDSC
    #######
    
    # Format for LDSC
    eqtl_gene_i_ldsc<-eqtl_gene_i[,c('SNP','A1','A2','slope','slope_se','N'), with=F]
    names(eqtl_gene_i_ldsc)<-c('SNP','A1','A2','BETA','SE','N')
    eqtl_gene_i_ldsc$Z<-eqtl_gene_i_ldsc$BETA/eqtl_gene_i_ldsc$SE
    eqtl_gene_i_ldsc<-eqtl_gene_i_ldsc[,c('SNP','A1','A2','Z','N'), with=F]
    
    # write in LDSC format
    fwrite(eqtl_gene_i_ldsc, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/LDSC/',gene_i,'.txt'), sep=' ', na = "NA", quote=F)
    
    # Run LDSC
    log4<-system(paste0('/scratch/prj/oliverpainfel/Software/ldsc/ldsc.py --h2 /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/LDSC/',gene_i,'.txt --ref-ld-chr /users/k1806347/oliverpainfel/Data/ldsc/eur_w_ld_chr/ --w-ld-chr /users/k1806347/oliverpainfel/Data/ldsc/eur_w_ld_chr/ --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/LDSC/',gene_i,'.h2'), intern=T)

    ########
    # Tabulate SNP-h2 results
    ########
    
    # Read SbayesR heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.SBayesR.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.SBayesR.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayesr_h2<-rbind(sbayesr_h2, par_res_file_i)
    }

    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.SBayesR_robust.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesR/',gene_i,'.SBayesR_robust.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayesr_robust_h2<-rbind(sbayesr_robust_h2, par_res_file_i)
    }

    # Read SbayesS heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesS/',gene_i,'.SBayesS.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/SBayesS/',gene_i,'.SBayesS.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayess_h2<-rbind(sbayess_h2, par_res_file_i)
    }
    
    # Read LDSC heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/LDSC/',gene_i,'.h2.log'))){
      
      par_res_file_i<-readLines(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/LDSC/',gene_i,'.h2.log'))
      par_res_file_i<-gsub('.*: ','',par_res_file_i[grepl('Total Observed scale h2',par_res_file_i)])
      hsq<-as.numeric(gsub(' .*','',par_res_file_i))
      se<-as.numeric(gsub(")",'',gsub(".*\\(",'',par_res_file_i)))
      p<-pnorm(hsq/se, lower.tail = F)
      
      ldsc_h2<-rbind(ldsc_h2, data.frame(gene=gene_i,
                                         hsq=hsq,
                                         se=se,
                                         p=p))
      
    }
  }
}

# Compare hsq estimates across methods
greml_h2<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/fusion/Whole_Blood.hsq')
names(greml_h2)<-c('PANEL','FILE','hsq','se','p')
greml_h2$gene<-gsub('WEIGHTS/Whole_Blood/Whole_Blood.','',greml_h2$FILE)
greml_h2<-greml_h2[, c('gene','hsq','se','p'), with=F]
greml_h2<-greml_h2[greml_h2$gene %in% genes,]

# Combine results across methods
sbayesr_h2$method<-'sbayesr'
sbayesr_robust_h2$method<-'sbayesr_robust'
sbayess_h2$method<-'sbayess'
ldsc_h2$method<-'ldsc'
greml_h2$method<-'greml'

all_h2<-do.call(rbind, list(sbayesr_h2, 
                            sbayesr_robust_h2, 
                            sbayess_h2, 
                            ldsc_h2, 
                            greml_h2))

write.table(all_h2, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/h2_estimates.txt', col.names=T, row.names=F, quote=F)

```

```{r, eval=F, echo=T}

# Plot the results
library(data.table)

all_h2<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/h2_estimates.txt')

library(UpSetR)

# Remove estimates which did not converge
all_h2<-all_h2[all_h2$se != 0,]

# Merge estimates an check correlation
all_h2_full_list<-split(all_h2[,c('gene','hsq'),with=F], f = all_h2$method)

for(i in names(all_h2_full_list)){
  names(all_h2_full_list[[which(names(all_h2_full_list) == i)]])<-c('gene',i)
}

all_h2_full_dat<-Reduce(function(...) merge(..., by='gene', all=T), all_h2_full_list)

library("ggplot2")
library("GGally")   

lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point() +
    geom_abline(intercept =0 , slope = 1, colour='red')
}  

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/h2_estimates.png', units = 'px', res=300, width=2000, height=2000)
ggpairs(all_h2_full_dat[,-1], lower = list(continuous = wrap(lowerfun)))
dev.off()

# Note. LDSC estimates are very inaccurate and do not correlated well with other methods. SBayesR correlates best wit GREML, and SBayesR and SBayesR with robust setting are highly correlated. The SBayesS method correlates less well with other methods, but this doesn't mean it is inaccurate as we don't know the truth.

# Check the number of genes that are significant in each method and how they overlap across methods.

# Extract significant estimates
all_h2_sig<-all_h2[all_h2$p < 0.01,]
n_gene<-data.frame(table(all_h2_sig$method))
names(n_gene)<-c('Method','N_genes')

# The number is similar across methods, but SBayesR has the highest.
all_h2_sig_list<-split(all_h2_sig[['gene']], f = all_h2_sig$method)

# Plot number of genes with valid and significant estimates
png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/n_sig_hsq.png', units = 'px', res=300, width=1500, height=1000)
upset(fromList(all_h2_sig_list), nsets=10, order.by = "freq")
dev.off()
# Again LDSC is least concordant with other methods.

# Compare number overlapping with GREML list
all_h2_greml_sig_list<-all_h2_sig_list
for(i in names(all_h2_greml_sig_list)){
  tmp<-all_h2_greml_sig_list[[which(names(all_h2_greml_sig_list) == i)]]
  tmp<-tmp[tmp %in% all_h2_greml_sig_list[['greml']]]
  all_h2_greml_sig_list[[which(names(all_h2_greml_sig_list) == i)]]<-tmp
}

n_gene$GREML_overlap<-unlist(lapply(all_h2_greml_sig_list, length))

write.csv(n_gene, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/n_sig_hsq.csv', row.names=F)

# Note. SBayesR has the largest overlap with GREML. Given this, and that SBayesR finds the most significant genes, I think we should use SBayesR without robust parameteristation to estimate heritability.

```

</details>

<details><summary>Show SNP-h2 estimates across methods</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/h2_estimates.png)

LDSC estimates are very inaccurate and do not correlated well with other methods. SBayesR correlates best wit GREML, and SBayesR and SBayesR with robust setting are highly correlated. The SBayesS method correlates less well with other methods, but this doesn't mean it is inaccurate as we don't know the truth.

</details>

<details><summary>Show number of genes with significant SNP-h2</summary>

```{r, eval=T, echo=F}
n_gene<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/n_sig_hsq.csv')
kable(n_gene, rownames = FALSE)

```

The number is similar across methods, but SBayesR has the highest.

SBayesR has the largest overlap with GREML. Given this, and that SBayesR finds the most significant genes, I think we should use SBayesR without robust parameteristation to estimate heritability.

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/n_sig_hsq.png)
Again LDSC is least concordant with other methods.

</details>

***

### Compare methods for generating SNP-weights

Now we have decided which genes to create SNP-weights for, we will generate SNP-weights for predicting gene expression using a range of methods. Then we will compare these SNP-weights to those derived by FUSION. Again, to avoid computational burden, start by running for the first 100 genes on chromosome 22.

<details><summary>Show code</summary>

```{r, eval=F, echo=T}

library(data.table)

# Make output directory
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR_robust')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/DBSLMM')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/PRScs')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SuSiE')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/RDat_files')

# Read in HapMap3 SNP-list
hm3_snp<-fread('/users/k1806347/oliverpainfel/Data/ldsc/w_hm3.snplist')

sbayesr_h2<-NULL

# Run across each chromosome seperately
for(chr_i in 22){
  # Read in eQTL data
  eqtl<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/Whole_Blood.allpairs.chr',chr_i,'.txt'))
  
  # Create CHR, BP, A1, A2, and Build columns
  var_id<-data.table(do.call(rbind, strsplit(eqtl$variant_id, '_')))
  names(var_id)<-c('CHR','BP','A1','A2','Build')
  var_id$CHR<-as.numeric(var_id$CHR)
  var_id$BP<-as.numeric(var_id$BP)
  
  eqtl<-cbind(eqtl, var_id)
  
  # Insert IUPAC codes for SNPs
  eqtl$IUPAC[eqtl$A1 == 'A' & eqtl$A2 =='T' | eqtl$A1 == 'T' & eqtl$A2 =='A']<-'W'
  eqtl$IUPAC[eqtl$A1 == 'C' & eqtl$A2 =='G' | eqtl$A1 == 'G' & eqtl$A2 =='C']<-'S'
  eqtl$IUPAC[eqtl$A1 == 'A' & eqtl$A2 =='G' | eqtl$A1 == 'G' & eqtl$A2 =='A']<-'R'
  eqtl$IUPAC[eqtl$A1 == 'C' & eqtl$A2 =='T' | eqtl$A1 == 'T' & eqtl$A2 =='C']<-'Y'
  eqtl$IUPAC[eqtl$A1 == 'G' & eqtl$A2 =='T' | eqtl$A1 == 'T' & eqtl$A2 =='G']<-'K'
  eqtl$IUPAC[eqtl$A1 == 'A' & eqtl$A2 =='C' | eqtl$A1 == 'C' & eqtl$A2 =='A']<-'M'
  
  # Remove INDELS
  eqtl<-eqtl[!is.na(eqtl$IUPAC),]
  
  # Calculate N for each association
  eqtl$N<-round((eqtl$ma_count/eqtl$maf)/2,1)
  
  # Check the build
  table(eqtl$Build) 
  # They are all b37
  
  ###
  # Insert RSIDs
  ###
  
  # Read in 1KG reference SNP data
  ref_bim_i<-fread(paste0('/users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/ref.chr',chr_i,'.bim'))

  names(ref_bim_i)<-c('CHR','SNP','POS','BP','A1','A2')
  
  # Extract hm3 SNPs
  ref_bim_i<-ref_bim_i[ref_bim_i$SNP %in% hm3_snp$SNP,]
  
  # Insert IUPAC codes
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'A' & ref_bim_i$A2 =='T' | ref_bim_i$A1 == 'T' & ref_bim_i$A2 =='A']<-'W'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'C' & ref_bim_i$A2 =='G' | ref_bim_i$A1 == 'G' & ref_bim_i$A2 =='C']<-'S'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'A' & ref_bim_i$A2 =='G' | ref_bim_i$A1 == 'G' & ref_bim_i$A2 =='A']<-'R'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'C' & ref_bim_i$A2 =='T' | ref_bim_i$A1 == 'T' & ref_bim_i$A2 =='C']<-'Y'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'G' & ref_bim_i$A2 =='T' | ref_bim_i$A1 == 'T' & ref_bim_i$A2 =='G']<-'K'
  ref_bim_i$IUPAC[ref_bim_i$A1 == 'A' & ref_bim_i$A2 =='C' | ref_bim_i$A1 == 'C' & ref_bim_i$A2 =='A']<-'M'

  # Merge target and reference based on position
  ref_target<-merge(eqtl, ref_bim_i, by=c('CHR','BP'))
  
  # I have used the GTEx reference data as well, and the same number is returned. 
  # Note: The A1 allele is the ref allele.
  # Small number of SNPs remaining highlights the limitation of using HapMap3 SNPs only.
  
  # Identify SNPs for which alleles need to be flipped
  flip_tmp<-ref_target[(ref_target$IUPAC.x == 'R' & ref_target$IUPAC.y == 'Y' | 
                          ref_target$IUPAC.x == 'Y' & ref_target$IUPAC.y == 'R' | 
                          ref_target$IUPAC.x == 'K' & ref_target$IUPAC.y == 'M' |
                          ref_target$IUPAC.x == 'M' & ref_target$IUPAC.y == 'K'),]
  
  # Idenitfy SNPs which match the reference alleles
  incl<-ref_target[ ref_target$IUPAC.x == 'R' & ref_target$IUPAC.y == 'R' | 
                      ref_target$IUPAC.x == 'Y' & ref_target$IUPAC.y == 'Y' | 
                      ref_target$IUPAC.x == 'K' & ref_target$IUPAC.y == 'K' |
                      ref_target$IUPAC.x == 'M' & ref_target$IUPAC.y == 'M' ]
  
  # If a SNP that needs to be flipped has a duplicate that is on the correct strand, remove it.
  flip<-flip_tmp[!(flip_tmp$SNP %in% incl$SNP)]
  
  # Flip alleles where necessary
  flip_tmp$A1_flipped<-flip_tmp$A1.x
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'A']<-'T'
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'T']<-'C'
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'G']<-'C'
  flip_tmp$A1_flipped[flip_tmp$A1.x == 'C']<-'G'
  flip_tmp$A1.x<-flip_tmp$A1_flipped
  flip_tmp$A1_flipped<-NULL
  
  flip_tmp$A2_flipped<-flip_tmp$A2.x
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'A']<-'T'
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'T']<-'C'
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'G']<-'C'
  flip_tmp$A2_flipped[flip_tmp$A2.x == 'C']<-'G'
  flip_tmp$A2.x<-flip_tmp$A2_flipped
  flip_tmp$A2_flipped<-NULL
  
  # Recombine and format
  eqtl_harm<-rbind(flip_tmp, incl)
  eqtl_harm<-eqtl_harm[,c('CHR','SNP','BP','A1.x','A2.x',"gene_id","variant_id","tss_distance","ma_samples","ma_count","maf","pval_nominal","slope","slope_se","N"), with=F]
  names(eqtl_harm)[names(eqtl_harm) == 'A1.x']<-'A1'
  names(eqtl_harm)[names(eqtl_harm) == 'A2.x']<-'A2'

  # Remove variants with MAF < 1%
  eqtl_harm<-eqtl_harm[eqtl_harm$maf >= 0.01,]
  
  eqtl<-eqtl_harm
  rm(eqtl_harm)
  
  # Identify unique genes 
  genes<-unique(eqtl$gene_id)
  genes<-genes[1:100]

  # Run for each gene seperately
  for(gene_i in genes){
    print(which(genes == gene_i))

    eqtl_gene_i<-eqtl[eqtl$gene_id == gene_i,]
    
    # Sort by chromosome and bp
    eqtl_gene_i<-eqtl_gene_i[order(eqtl_gene_i$CHR, eqtl_gene_i$BP),]

    # Filter SNPs to those with N > 80% of max(N)
    eqtl_gene_i<-eqtl_gene_i[eqtl_gene_i$N >= 0.8*max(eqtl_gene_i$N),]
    
    #######
    # SBayesR
    #######
    
    # Format for SBayesR
    eqtl_gene_i_sbayesr<-eqtl_gene_i[,c('SNP','A1','A2','maf','slope','slope_se','pval_nominal','N'), with=F]
    names(eqtl_gene_i_sbayesr)<-c('SNP','A1','A2','freq','b','se','p','N')
    
    # write in SBayesR format
    fwrite(eqtl_gene_i_sbayesr, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.txt'), sep=' ', na = "NA", quote=F)
    
    # Run SBayesR
    log<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes R --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.95,0.02,0.02,0.01 --gamma 0.0,0.01,0.1,1 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.txt --chain-length 10000 --exclude-mhc --burn-in 2000 --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.SBayesR'), intern=T)
    
    # Read SbayesR heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.SBayesR.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.SBayesR.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayesr_h2<-rbind(sbayesr_h2, par_res_file_i)
      
      # If SNP-h2 p < 0.01, generate SNP-weights
      if(par_res_file_i$p < 0.01){
        # Flip the effect of each method to match eqtl sumstats
        ref_tmp<-eqtl_gene_i[, c('SNP','A1','A2'), with=F]
        
        #############
        # SBayesR
        #############
        # SBayesR has already been run, so just read in the SNP-weights
        sbayesr_score<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.SBayesR.snpRes'))
        sbayesr_score<-sbayesr_score[,c('Name','A1','A2','A1Effect'), with=F]
        names(sbayesr_score)<-c('SNP','A1','A2','BETA')
        
        # Flip effects so allele match eQTL sumstats
        sbayesr_score<-merge(ref_tmp, sbayesr_score, by='SNP', all=T)
        sbayesr_score$BETA[which(sbayesr_score$A1.x == sbayesr_score$A2.y)]<--sbayesr_score$BETA[which(sbayesr_score$A1.x == sbayesr_score$A2.y)]
        sbayesr_score<-sbayesr_score[,c('SNP','A1.x','A2.x','BETA'), with=F]
        names(sbayesr_score)<-c('SNP','A1','A2','BETA')
        
        # Sort score file according eqtl_gene_i
      sbayesr_score<-sbayesr_score[match(eqtl_gene_i$SNP, sbayesr_score$SNP),]

        #############
        # SBayesR robust
        #############
        # SBayesR format sumstats are already available
        # So just run SBayesR with robust setting
        
        log<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes R --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.95,0.02,0.02,0.01 --gamma 0.0,0.01,0.1,1 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR/',gene_i,'.txt --robust --chain-length 10000 --exclude-mhc --burn-in 2000 --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR_robust/',gene_i,'.SBayesR'), intern=T)

        # Read in the results
        sbayesr_robust_score<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SBayesR_robust/',gene_i,'.SBayesR.snpRes'))
        sbayesr_robust_score<-sbayesr_robust_score[,c('Name','A1','A2','A1Effect'), with=F]
        names(sbayesr_robust_score)<-c('SNP','A1','A2','BETA')
        
        # Flip effects so allele match eQTL sumstats
        sbayesr_robust_score<-merge(ref_tmp, sbayesr_robust_score, by='SNP', all=T)
        sbayesr_robust_score$BETA[which(sbayesr_robust_score$A1.x == sbayesr_robust_score$A2.y)]<--sbayesr_robust_score$BETA[which(sbayesr_robust_score$A1.x == sbayesr_robust_score$A2.y)]
        sbayesr_robust_score<-sbayesr_robust_score[,c('SNP','A1.x','A2.x','BETA'), with=F]
        names(sbayesr_robust_score)<-c('SNP','A1','A2','BETA')

        # Sort score file according eqtl_gene_i
      sbayesr_robust_score<-sbayesr_robust_score[match(eqtl_gene_i$SNP, sbayesr_robust_score$SNP),]

        #############
        # DBSLMM
        #############
        
        # Convert to GEMMA format
        eqtl_gene_i_dbslmm<-eqtl_gene_i
        eqtl_gene_i_dbslmm$N_MISS<-max(eqtl_gene_i_dbslmm$N)-eqtl_gene_i_dbslmm$N
        eqtl_gene_i_dbslmm<-eqtl_gene_i_dbslmm[,c('CHR','SNP','BP','N_MISS','N','A1','A2','maf','slope','slope_se','pval_nominal'),with=F]
          names(eqtl_gene_i_dbslmm)<-c('chr','rs','ps','n_mis','n_obs','allele1','allele0','af','beta','se','p_wald')
        
        # Match allele1 and 0 with A1 and 2 in reference (DBSLMM calls this allele discrepancy)
        # Use the GenoDisc prepared ref data (1kg eur)
        ref_bim_subset<-fread(paste0('/users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',chr_i,'.bim'))
      
        GWAS_match<-merge(eqtl_gene_i_dbslmm, ref_bim_subset[,c('V2','V5','V6'),with=F], by.x=c('rs','allele1','allele0'), by.y=c('V2','V5','V6'))
        GWAS_switch<-merge(eqtl_gene_i_dbslmm, ref_bim_subset[,c('V2','V5','V6'),with=F], by.x=c('rs','allele1','allele0'), by.y=c('V2','V6','V5'))
        GWAS_switch$allele_tmp<-GWAS_switch$allele0
        GWAS_switch$allele0<-GWAS_switch$allele1
        GWAS_switch$allele1<-GWAS_switch$allele_tmp
        GWAS_switch$allele_tmp<-NULL
        GWAS_switch$beta<--GWAS_switch$beta
        GWAS_switch$af<-1-GWAS_switch$af
        GWAS<-rbind(GWAS_match, GWAS_switch)
        
        GWAS<-GWAS[order(GWAS$chr, GWAS$ps),]
        GWAS<-GWAS[,c('chr','rs','ps','n_mis','n_obs','allele1','allele0','af','beta','se','p_wald'),with=F]
        GWAS_N<-mean(GWAS$n_obs)
        nsnp<-nrow(GWAS)
        
        # Write out formatted sumstats
        fwrite(GWAS, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/DBSLMM/',gene_i,'.DBSLMM'), sep='\t', col.names=F)

        # Run dbslmm
        system('chmod 777 /users/k1806347/oliverpainfel/Software/DBSLMM/software/dbslmm')
        system(paste0('/users/k1806347/oliverpainfel/Software/Rscript.sh /users/k1806347/oliverpainfel/Software/DBSLMM/software/DBSLMM.R --plink /users/k1806347/oliverpainfel/Software/plink1.9.sh --block /users/k1806347/oliverpainfel/Data/LDetect/EUR/fourier_ls-chr',chr_i,'.bed --dbslmm /users/k1806347/oliverpainfel/Software/DBSLMM/software/dbslmm --h2 ',par_res_file_i$hsq,' --ref /users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',chr_i,' --summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/DBSLMM/',gene_i,'.DBSLMM --n ',round(GWAS_N,0),' --nsnp ',nsnp,' --outPath /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/DBSLMM/ --thread 1'))

        # Read in the results
        dbslmm_score<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/DBSLMM/',gsub('\\..*','',gene_i),'.dbslmm.txt'))
        dbslmm_score<-dbslmm_score[,c(1,2,4), with=T]
        names(dbslmm_score)<-c('SNP','A1','BETA')

        # Flip effects so allele match eQTL sumstats
        dbslmm_score<-merge(ref_tmp, dbslmm_score, by='SNP', all=T)
        dbslmm_score$BETA[which(dbslmm_score$A1.x != dbslmm_score$A1.y)]<--dbslmm_score$BETA[which(dbslmm_score$A1.x != dbslmm_score$A1.y)]
        dbslmm_score<-dbslmm_score[,c('SNP','A1.x','A2','BETA'), with=F]
        names(dbslmm_score)<-c('SNP','A1','A2','BETA')

        # Sort score file according eqtl_gene_i
      dbslmm_score<-dbslmm_score[match(eqtl_gene_i$SNP, dbslmm_score$SNP),]

        ##############
        # PRScs
        ##############
        
        # Format for PRScs
        eqtl_gene_i_prscs<-eqtl_gene_i[,c('SNP','A1','A2','slope','pval_nominal'), with=F]
        names(eqtl_gene_i_prscs)<-c('SNP','A1','A2','BETA','P')
        
        # write in PRScs format
        fwrite(eqtl_gene_i_prscs, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/PRScs/',gene_i,'.txt'), sep=' ', na = "NA", quote=F)

        system(paste0('/users/k1806347/oliverpainfel/Software/PRScs.sh --ref_dir=/users/k1806347/oliverpainfel/Software/PRScs/ldblk_1kg_eur --bim_prefix=/users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',chr_i,' --sst_file=/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/PRScs/',gene_i,'.txt --n_gwas=',round(GWAS_N,0),' --out_dir=/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/PRScs/',gene_i,' --chrom=',chr_i))

        # Read in the results
        prscs_score<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/PRScs/',gene_i,'_pst_eff_a1_b0.5_phiauto_chr22.txt'))
        prscs_score<-prscs_score[,c('V2','V4','V6'), with=F]
        names(prscs_score)<-c('SNP','A1','BETA')

        # Flip effects so allele match eQTL sumstats
        prscs_score<-merge(ref_tmp, prscs_score, by='SNP', all=T)
        prscs_score$BETA[which(prscs_score$A1.x != prscs_score$A1.y)]<--prscs_score$BETA[which(prscs_score$A1.x != prscs_score$A1.y)]
        prscs_score<-prscs_score[,c('SNP','A1.x','A2','BETA'), with=F]
        names(prscs_score)<-c('SNP','A1','A2','BETA')
        
        # Sort score file according eqtl_gene_i
      prscs_score<-prscs_score[match(eqtl_gene_i$SNP, prscs_score$SNP),]

        # Note PRScs takes a lot longer than other methods.
        
        ################
        # SuSiE finemapping
        ################
        
        # Read LD estimates for eQTL sumstats
        write.table(eqtl_gene_i$SNP, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SuSiE/',gene_i,'_snps.txt'), col.names=F, row.names=F, quote=F)
        system(paste0('/users/k1806347/oliverpainfel/Software/plink1.9.sh --bfile /users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',chr_i,' --extract /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SuSiE/',gene_i,'_snps.txt --r square --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SuSiE/',gene_i))

        ld<-as.matrix(fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/SuSiE/',gene_i,'.ld')))

        library(susieR)
        
        tryCatch(fitted_rss <- susie_rss(eqtl_gene_i$slope/eqtl_gene_i$slope_se, ld, L = 10), error = function(e){skip_to_next <<- TRUE})
        
        skip_to_next<-F
        if(skip_to_next == TRUE){
          susie_score<-data.table(SNP=eqtl_gene_i$SNP,
                                  A1=eqtl_gene_i$A1,
                                  BETA=NA)
        } else {
          susie_score<-data.table(SNP=eqtl_gene_i$SNP,
                        A1=eqtl_gene_i$A1,
                        BETA=eqtl_gene_i$slope*fitted_rss$pip)
        }
        
        # Flip effects so allele match eQTL sumstats
        susie_score<-merge(ref_tmp, susie_score, by='SNP', all=T)
        susie_score$BETA[which(susie_score$A1.x != susie_score$A1.y)]<--susie_score$BETA[which(susie_score$A1.x != susie_score$A1.y)]
        susie_score<-susie_score[,c('SNP','A1.x','A2','BETA'), with=F]
        names(susie_score)<-c('SNP','A1','A2','BETA')
        
        # Sort score file according eqtl_gene_i
      susie_score<-susie_score[match(eqtl_gene_i$SNP, susie_score$SNP),]

        # Create RDat file for FUSION
        cv.performance<-as.matrix(data.frame(sbayesr=c(NA,NA),
                                             sbayesr_robust=c(NA,NA),
                                             dbslmm=c(NA,NA),
                                             prscs=c(NA,NA),
                                             susie=c(NA,NA),
                                             top1=c(NA,NA), 
                                             row.names=c('rsq','pval')))
        
        # Sort eQTL data into the same order as other score files
        eqtl_gene_i<-eqtl_gene_i[match(sbayesr_score$SNP, eqtl_gene_i$SNP),]
        
        hsq<-c(par_res_file_i$hsq, par_res_file_i$se)
        hsq.pv<-par_res_file_i$p
        N.tot<-max(eqtl_gene_i$N)
        eqtl_gene_i$POS<-0
        snps<-eqtl_gene_i[,c('CHR','SNP','POS','BP','A1','A2')]
        names(snps)<-paste0('V',1:length(names(snps)))
        
        wgt.matrix<-as.matrix(data.frame(sbayesr=sbayesr_score$BETA,
                                         sbayesr_robust=sbayesr_robust_score$BETA,
                                         dbslmm=dbslmm_score$BETA,
                                         prscs=prscs_score$BETA,
                                         susie=susie_score$BETA,
                                         top1=eqtl_gene_i$slope,
                                         row.names=snps$V2))
        
        save(cv.performance, 
             hsq,
             hsq.pv,
             N.tot,
             snps,
             wgt.matrix,
             file = paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/RDat_files/',gene_i,'.RDat'))
      }
    }
  }
}

```

```{r, echo=T, eval=F}

library(data.table)

fusion_pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/fusion/Whole_Blood.pos')
fusion_pos<-fusion_pos[fusion_pos$CHR == 22,]

dim(fusion_pos) # 436

eqtl_derived_files<-list.files(path='/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/RDat_files/', pattern='.RDat')
fusion_files<-list.files(path='/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/fusion/Whole_Blood/', pattern='.RDat')

length(eqtl_derived_files) # 36
length(fusion_files) # 13909

eqtl_derived_files<-gsub('.RDat','',eqtl_derived_files)
fusion_files<-gsub('.wgt.RDat','',gsub('Whole_Blood.','',fusion_files))

genes<-intersect(eqtl_derived_files, fusion_files)
length(genes) # 36

nsnp_res<-NULL
hsq_res<-NULL
cor_res<-list()

for(genes_i in genes){
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/RDat_files/',genes_i,'.RDat'))
  eqtl_derived<-data.frame(wgt.matrix)
  if(sum(eqtl_derived$susie) == 0){
    eqtl_derived$susie<-NA
  }
  eqtl_derived$SNP<-row.names(eqtl_derived)
  sbayesr<-c(hsq, hsq.pv)
  
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/fusion/Whole_Blood/Whole_Blood.',genes_i,'.wgt.RDat'))
  fusion<-data.frame(wgt.matrix)
  fusion$SNP<-row.names(fusion)
  greml<-c(hsq, hsq.pv)
  
  nsnp_res<-rbind(nsnp_res, data.frame(gene_id=genes_i,
                                       nsnp_eqtl_derived=nrow(eqtl_derived),
                                       nsnp_fusion=nrow(fusion)))
  
  hsq_res<-rbind(hsq_res, data.frame(gene_id=genes_i,
                                     sbayesr_h2=sbayesr[1],
                                     sbayesr_se=sbayesr[2],
                                     sbayesr_p=sbayesr[3],
                                     greml_h2=greml[1],
                                     greml_se=greml[2],
                                     greml_p=greml[3]))

  both<-merge(eqtl_derived, fusion, by='SNP')
  
  if(nrow(both) > 0){
    cor_res[[genes_i]]<-cor(both[,-1], use='p')
  }
}

# Compare h2
cor(hsq_res$sbayesr_h2, hsq_res$greml_h2) # 0.7653649

library(ggplot2)
png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/h2_comp.png', units='px', width=1000, height=1000, res=300)
ggplot(hsq_res, aes(x=sbayesr_h2, y=greml_h2)) +
  geom_abline(intercept =0 , slope = 1, colour='red') +
  geom_point() +
  coord_fixed() +
  xlim(0,1) +
  ylim(0,1)
dev.off()

# Compare nsnp
cor(nsnp_res$nsnp_eqtl_derived, nsnp_res$nsnp_fusion) # 0.4840981

library(ggplot2)
png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/nsnp_comp.png', units='px', width=1000, height=1000, res=300)
ggplot(nsnp_res, aes(x=nsnp_eqtl_derived, y=nsnp_fusion)) +
  geom_abline(intercept =0 , slope = 1, colour='red') +
  geom_point() +
  coord_fixed()
dev.off()

# Check SNP-weight correlations
cor_res_melt<-melt(cor_res)
cor_res_melt$Var1<-gsub('top1.x','top1.GTEx',cor_res_melt$Var1)
cor_res_melt$Var2<-gsub('top1.x','top1.GTEx',cor_res_melt$Var2)
cor_res_melt$Var1<-gsub('top1.y','top1.FUSION',cor_res_melt$Var1)
cor_res_melt$Var2<-gsub('top1.y','top1.FUSION',cor_res_melt$Var2)
cor_res_melt$test<-paste0(cor_res_melt$Var1,'_',cor_res_melt$Var2)

cor_res_average<-NULL
for(i in unique(cor_res_melt$test)){
  cor_res_average<-rbind(cor_res_average, data.frame(test=i,
                                                     Mean=mean(cor_res_melt$value[cor_res_melt$test == i])))
}

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/cor_plot.png', units='px', width=3000, height=3000, res=300)
ggplot(cor_res_melt, aes(x=paste0(Var1,' vs. ',Var2), y=value)) +
  geom_boxplot() +
  coord_flip()
dev.off()

```

</details>

<details><summary>Show GREML and SBayesR SNP-h2 estimates</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/h2_comp.png)

</details>

<details><summary>Show number of variants in FUSION and eQTL-based models</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/nsnp_comp.png)

</details>

<details><summary>Show correlation between FUSION and eQTL-based models</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v7/snp_weight_comp/cor_plot.png)

</details>

<br/>

The correlation between eQTL derived TWAS weights and FUSION derived TWAS weights is similar to correlation between different FUSION models. 

The correlation between eQTL derived and FUSION weights is of interest, but not a good evaluation metric of methods, We should compare the correlation between predicted and observed expression, when using eQTL derived TWAS weights or largest FUSION TWAS weights.

The low correlation between topSNP results from FUSION and GTEx indicates comparison of FUSION and eQTL susmtat derived weights are not very informative.

***

## SNP-h2 estimation using GTEx v8

Compare SNP-h2 estimates using GTEx v8 eQTL sumstats to GREML: Here we will use the top1 model within the FUSION weights to derive eQTL summary statistics. This will provide a direct comparison between SNP-h2 estimates from sumstat and GREML. Only use genes on chromosome 22.

#### Format eQTL sumstats

<details><summary>Show code</summary>

```{bash}
# Download the FUSION SNP weights for GTEx v8 whole blood
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/fusion
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/fusion
wget https://s3.us-west-1.amazonaws.com/gtex.v8.fusion/EUR/GTExv8.EUR.Whole_Blood.tar.gz
tar -xvzf GTExv8.EUR.Whole_Blood.tar.gz
rm GTExv8.EUR.Whole_Blood.tar.gz

# Download the FUSION LD reference data to be consistent
cd /users/k1806347/oliverpainfel/Data/1KG/FUSION/
wget https://data.broadinstitute.org/alkesgroup/FUSION/LDREF.tar.bz2
tar xjvf LDREF.tar.bz2
rm LDREF.tar.bz2
mv LDREF/* ./
rm -r LDREF

# Calculate allele frequency
for chr in $(seq 1 22); do 
  ~/oliverpainfel/Software/plink1.9.sh --bfile 1000G.EUR.${chr} --freq --out 1000G.EUR.${chr}
done

```

```{r, echo=T, eval=F}
# conda activate /scratch/prj/oliverpainfel/Software/MyGit/GenoPred/pipeline/.snakemake/conda/aea4ef260655c3bcc12fec8909f5f6dd_

library(data.table)

# Read in the pos file
pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/fusion/GTExv8.EUR.Whole_Blood.nofilter.pos')
pos<-pos[pos$CHR == 22,]

# Read in EUR MAF
frq<-NULL
for(i in 1:22){
  frq<-rbind(frq, fread(paste0('/users/k1806347/oliverpainfel/Data/1KG/FUSION//1000G.EUR.',i,'.frq')))
}
names(frq)[names(frq) == 'MAF']<-'FREQ'

setkey(frq, SNP)

for(i in 1:nrow(pos)){
  print(i)
  
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/fusion/',pos$WGT[i]))
  tmp<-data.table(cbind(snps, wgt.matrix[,which(colnames(wgt.matrix) == 'top1')]))
  names(tmp)<-c('CHR','SNP','POS','BP','A1','A2','Z')
  tmp$N<-pos$N[i]
  
  frq_tmp<-frq[.(tmp$SNP)]
  
  # Insert EUR MAF
  tmp_match<-merge(tmp, frq_tmp[,c('SNP','A1','A2','FREQ'),with=F], by=c('SNP','A1','A2'))
  tmp_flip<-merge(tmp, frq_tmp[,c('SNP','A1','A2','FREQ'),with=F], by.x=c('SNP','A1','A2'), by.y=c('SNP','A2','A1'))
  tmp_flip$FREQ<-1-tmp_flip$FREQ
  tmp<-rbind(tmp_match, tmp_flip)
  
  # Approximate BETA, SE, and P
  tmp$P<-2*pnorm(-abs(tmp$Z))
  tmp$BETA<-tmp$Z/sqrt((2*tmp$FREQ)*(1-tmp$FREQ)*(tmp$N+(tmp$Z^2)))
  tmp$SE<-abs(tmp$BETA)/abs(tmp$Z)
  
  tmp$GENE<-pos$ID[i]
    
  tmp<-tmp[,c('GENE','CHR','SNP','BP','A1','A2','BETA','SE','Z','P','FREQ','N'),with=F]
  
  if(i == 1){
    write.table(tmp, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/GTEx_v8_eQTL_from_fusion.txt', col.names=T, row.names=F, quote=F)
  } else {
    write.table(tmp, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/GTEx_v8_eQTL_from_fusion.txt', col.names=F, row.names=F, quote=F, append=T)
  }
}

```

</details>

***

### Estimate SNP-h2

```{r, eval=F, echo=T}
library(data.table)
library(ggplot2)
library(cowplot)

# Make output directory
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesS')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/LDSC')
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/RDat_files')

# Read in HapMap3 SNP-list
hm3_snp<-fread('/users/k1806347/oliverpainfel/Data/ldsc/w_hm3.snplist')

sbayesr_h2<-NULL
sbayesr_robust_h2<-NULL
sbayess_h2<-NULL
ldsc_h2<-NULL

# Run across each chromosome seperately
for(chr_i in 22){
  # Read in eQTL data
  eqtl<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/GTEx_v8_eQTL_from_fusion.txt'))
  eqtl<-eqtl[eqtl$FREQ >= 0.01 & eqtl$FREQ <= 0.99]
  
  # Identify unique genes 
  genes<-unique(eqtl$GENE)
  
  # Read in LDscores for insight into LDSC results
  ldscores<-fread('/users/k1806347/oliverpainfel/Data/ldsc/eur_w_ld_chr/22.l2.ldscore.gz')
  
  # Run for each gene seperately
  for(gene_i in genes){
    print(which(genes == gene_i))

    eqtl_gene_i<-eqtl[eqtl$GENE == gene_i,]
    
    #######
    # SBayesR
    #######
    
    # Format for SBayesR
    eqtl_gene_i_sbayesr<-eqtl_gene_i[,c('SNP','A1','A2','FREQ','BETA','SE','P','N'), with=F]
    names(eqtl_gene_i_sbayesr)<-c('SNP','A1','A2','freq','b','se','p','N')
    
    # write in SBayesR format
    fwrite(eqtl_gene_i_sbayesr, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.txt'), sep=' ', na = "NA", quote=F)
    
    # Run SBayesR
    log<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes R --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.95,0.02,0.02,0.01 --gamma 0.0,0.01,0.1,1 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.txt --chain-length 10000 --exclude-mhc --burn-in 2000 --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.SBayesR'), intern=T)
    
    # Run SBayesR
    log2<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes R --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.95,0.02,0.02,0.01 --gamma 0.0,0.01,0.1,1 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.txt --chain-length 10000 --robust --exclude-mhc --burn-in 2000 --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.SBayesR_robust'), intern=T)
    
    #######
    # SBayesS
    #######
    
    # Run SBayesS
    log3<-system(paste0('/users/k1806347/oliverpainfel/Software/gctb_2.03beta_Linux/gctb_203.sh --sbayes S --ldm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr',chr_i,'.ldm.sparse --pi 0.1 --hsq 0.5 --chain-length 25000 --burn-in 5000 --gwas-summary /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.txt --exclude-mhc --out-freq 1000 --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesS/',gene_i,'.SBayesS'), intern=T)
    
    #######
    # LDSC
    #######
    
    # Format for LDSC
    eqtl_gene_i_ldsc<-eqtl_gene_i[,c('SNP','A1','A2','BETA','SE','N'), with=F]
    names(eqtl_gene_i_ldsc)<-c('SNP','A1','A2','BETA','SE','N')
    eqtl_gene_i_ldsc$Z<-eqtl_gene_i_ldsc$BETA/eqtl_gene_i_ldsc$SE
    eqtl_gene_i_ldsc<-eqtl_gene_i_ldsc[,c('SNP','A1','A2','Z','N'), with=F]
    
    # write in LDSC format
    fwrite(eqtl_gene_i_ldsc, paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/LDSC/',gene_i,'.txt'), sep=' ', na = "NA", quote=F)
    
    # Run LDSC
    log4<-system(paste0('/users/k1806347/oliverpainfel/Software/ldsc.sh --h2 /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/LDSC/',gene_i,'.txt --ref-ld-chr /users/k1806347/oliverpainfel/Data/ldsc/eur_w_ld_chr/ --w-ld-chr /users/k1806347/oliverpainfel/Data/ldsc/eur_w_ld_chr/ --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/LDSC/',gene_i,'.h2'), intern=T)
    
    ########
    # Tabulate SNP-h2 results
    ########
    
    # Read SbayesR heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.SBayesR.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.SBayesR.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayesr_h2<-rbind(sbayesr_h2, par_res_file_i)
    }

    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.SBayesR_robust.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesR/',gene_i,'.SBayesR_robust.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayesr_robust_h2<-rbind(sbayesr_robust_h2, par_res_file_i)
    }

    # Read SbayesS heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesS/',gene_i,'.SBayesS.parRes'))){
      
      par_res_file_i<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/SBayesS/',gene_i,'.SBayesS.parRes'))
      par_res_file_i<-par_res_file_i[par_res_file_i$V1 == 'hsq',2:3, with=F]
      par_res_file_i$P<-pnorm(-abs(par_res_file_i$Mean/par_res_file_i$SD))
      par_res_file_i$Gene<-gene_i
      par_res_file_i<-par_res_file_i[,c('Gene','Mean','SD','P'), with=F]
      names(par_res_file_i)<-c('gene','hsq','se','p')
      sbayess_h2<-rbind(sbayess_h2, par_res_file_i)
    }
    
    # Read LDSC heritability result
    if(file.exists(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/LDSC/',gene_i,'.h2.log'))){
      
      par_res_file_i<-readLines(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/LDSC/',gene_i,'.h2.log'))
      par_res_file_i<-gsub('.*: ','',par_res_file_i[grepl('Total Observed scale h2',par_res_file_i)])
      if(length(par_res_file_i) != 0){
        hsq<-as.numeric(gsub(' .*','',par_res_file_i))
        se<-as.numeric(gsub(")",'',gsub(".*\\(",'',par_res_file_i)))
        p<-pnorm(hsq/se, lower.tail = F)
      
        ldsc_h2<-rbind(ldsc_h2, data.frame(gene=gene_i,
                                         hsq=hsq,
                                         se=se,
                                         p=p))

      }
    }
  }
}

# Compare hsq estimates across methods
fusion_files<-list.files(path='/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/fusion/GTExv8.EUR.Whole_Blood', pattern='.RDat')
fusion_files<-gsub('.wgt.RDat','',fusion_files)
fusion_files<-intersect(fusion_files, genes)

greml_h2<-NULL

for(genes_i in fusion_files){
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/fusion/GTExv8.EUR.Whole_Blood/',genes_i,'.wgt.RDat'))
  fusion<-data.frame(wgt.matrix)
  fusion$SNP<-row.names(fusion)
  greml<-c(hsq, hsq.pv)

  greml_h2<-rbind(greml_h2, data.frame(gene=genes_i,
                                         hsq=greml[1],
                                         se=greml[2],
                                         p=greml[3]))
}

# Combine results across methods
sbayesr_h2$method<-'sbayesr'
sbayesr_robust_h2$method<-'sbayesr_robust'
sbayess_h2$method<-'sbayess'
ldsc_h2$method<-'ldsc'
greml_h2$method<-'greml'

all_h2<-do.call(rbind, list(sbayesr_h2, 
                            sbayesr_robust_h2, 
                            sbayess_h2, 
                            ldsc_h2, 
                            greml_h2))

write.table(all_h2, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/h2_estimates.txt', col.names=T, row.names=F, quote=F)

```

```{bash, eval=F, echo=T}
# Run using mbat-combo to see whether this could work as an inclusion criteria
sbatch -p cpu --mem 10G -n 1 --nodes 1 /users/k1806347/oliverpainfel/Software/Rscript.sh /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/private/eQTL_mbat_combo.R \
	--chr 22 \
	--extract /users/k1806347/oliverpainfel/Data/ldsc/w_hm3.snplist \
	--sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/GTEx_v8_eQTL_from_fusion.txt \
	--plink_ref_chr /users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/ref.chr \
	--plink_ref_keep /users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/keep_files/EUR.keep \
	--gcta /users/k1806347/oliverpainfel/Software/gcta_1.94.sh \
  --output /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/GTEx_v8.mbat.combo

```

```{r, eval=F, echo=T}

# Plot the results
library(data.table)

all_h2<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/h2_estimates.txt')

library(UpSetR)

# Remove estimates which did not converge
all_h2<-all_h2[all_h2$se != 0,]

# Merge estimates an check correlation
all_h2_full_list<-split(all_h2[,c('gene','hsq'),with=F], f = all_h2$method)

for(i in names(all_h2_full_list)){
  names(all_h2_full_list[[which(names(all_h2_full_list) == i)]])<-c('gene',i)
}

all_h2_full_dat<-Reduce(function(...) merge(..., by='gene', all=T), all_h2_full_list)

library("ggplot2")
library("GGally")   
library('stringr')

n_gene<-data.frame(Method=names(all_h2_full_dat)[-1],
           N_genes=apply(all_h2_full_dat[,-1], 2, function(x) sum(!is.na(x))))
           
lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point() +
    geom_abline(intercept =0 , slope = 1, colour='red')
}  

upperfun <- function (data, mapping, ..., stars = TRUE, method = "pearson", 
    use = "complete.obs", display_grid = FALSE, digits = 3, title_args = list(...), 
    group_args = list(...), justify_labels = "right", align_percent = 0.5, 
    title = NULL, alignPercent = warning("deprecated. Use `align_percent`"), 
    displayGrid = warning("deprecated. Use `display_grid`")) 
{
    if (!missing(alignPercent)) {
        warning("`alignPercent` is deprecated. Please use `align_percent` if alignment still needs to be adjusted")
        align_percent <- alignPercent
    }
    if (!missing(displayGrid)) {
        warning("`displayGrid` is deprecated. Please use `display_grid`")
        display_grid <- displayGrid
    }
    na.rm <- if (missing(use)) {
        NA
    }
    else {
        (use %in% c("complete.obs", "pairwise.complete.obs", 
            "na.or.complete"))
    }
    ggally_statistic(data = data, mapping = mapping, na.rm = na.rm, 
        align_percent = align_percent, display_grid = display_grid, 
        title_args = title_args, group_args = group_args, justify_labels = justify_labels, 
        justify_text = "left", sep = if ("colour" %in% names(mapping)) 
            ": "
        else "", title = title, text_fn = function(x, y) {
            corObj <- stats::cor.test(x, y, method = method, 
                use = use)
            cor_est <- as.numeric(corObj$estimate)
            cor_txt <- paste0('Corr = ',round(cor_est,3))
            N_txt <- paste0('\n\nN = ', sum(!is.na(rowSums(cbind(x, y)))))
            if (isTRUE(stars)) {
                cor_txt <- str_c(cor_txt, signif_stars(corObj$p.value), N_txt)
            }
            cor_txt
        })
}

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/h2_estimates.png', units = 'px', res=300, width=2000, height=2000)
ggpairs(all_h2_full_dat[,-1], lower = list(continuous = wrap(lowerfun)), upper = list(continuous = wrap(upperfun))) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
dev.off()

# Note. LDSC estimates are very inaccurate and do not correlated well with other methods. SBayesR correlates best wit GREML, and SBayesR and SBayesR with robust setting are highly correlated. The SBayesS method correlates less well with other methods, but this doesn't mean it is inaccurate as we don't know the truth.

# Check the number of genes that are significant in each method and how they overlap across methods.

# Extract significant estimates
# and remove negative SNP-h2
all_h2_sig<-all_h2[all_h2$p < 0.01,]
all_h2_sig<-all_h2_sig[all_h2_sig$hsq > 0]
names(n_gene)<-c('Method','N_converge')
n_gene$N_genes<-table(all_h2_sig$method)

# The number is similar across methods, but SBayesR has the highest.
all_h2_sig_list<-split(all_h2_sig[['gene']], f = all_h2_sig$method)

# Include the fastbat results
mbat_res<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/GTEx_v8.mbat.combo.res.txt')

fastbat_res_sig<-mbat_res[mbat_res$P_fastBAT < 0.01 | mbat_res$TopSNP_Pvalue < 5e-8,]
n_gene<-rbind(n_gene, data.table(Method='fastbat', N_converge=nrow(mbat_res), N_genes=nrow(fastbat_res_sig)))
all_h2_sig_list[['fastbat']]<-fastbat_res_sig$Gene

mbat_combo_res_sig<-mbat_res[mbat_res$P_mBAT  < 0.01 | mbat_res$TopSNP_Pvalue < 5e-8,]
n_gene<-rbind(n_gene, data.table(Method='mbat', N_converge=nrow(mbat_res), N_genes=nrow(mbat_res_sig)))
all_h2_sig_list[['mbat']]<-mbat_combo_res_sig$Gene

mbat_combo_res_sig<-mbat_res[mbat_res$P_mBATcombo < 0.01 | mbat_res$TopSNP_Pvalue < 5e-8,]
n_gene<-rbind(n_gene, data.table(Method='mbat_combo', N_converge=nrow(mbat_res), N_genes=nrow(mbat_combo_res_sig)))
all_h2_sig_list[['mbat_combo']]<-mbat_combo_res_sig$Gene

any_mbat_combo_res_sig<-mbat_res[mbat_res$P_mBATcombo < 0.01 | mbat_res$P_mBAT < 0.01 | mbat_res$P_fastBAT < 0.01 | mbat_res$TopSNP_Pvalue < 5e-8,]
n_gene<-rbind(n_gene, data.table(Method='any_mbat_combo', N_converge=nrow(mbat_res), N_genes=nrow(any_mbat_combo_res_sig)))
all_h2_sig_list[['any_mbat_combo']]<-mbat_combo_res_sig$Gene

# Plot number of genes with valid and significant estimates
png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/n_sig_hsq.png', units = 'px', res=300, width=1500, height=1000)
upset(fromList(all_h2_sig_list), nsets=10, order.by = "freq")
dev.off()
# Again LDSC is least concordant with other methods.

# Compare number overlapping with GREML list
all_h2_greml_sig_list<-all_h2_sig_list
for(i in names(all_h2_greml_sig_list)){
  tmp<-all_h2_greml_sig_list[[which(names(all_h2_greml_sig_list) == i)]]
  tmp<-tmp[tmp %in% all_h2_greml_sig_list[['greml']]]
  all_h2_greml_sig_list[[which(names(all_h2_greml_sig_list) == i)]]<-tmp
}

n_gene$GREML_overlap<-unlist(lapply(all_h2_greml_sig_list, length))

write.csv(n_gene, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/n_sig_hsq.csv', row.names=F)

# Note. SBayesR has the largest overlap with GREML. Given this, and that SBayesR finds the most significant genes, I think we should use SBayesR without robust parameteristation to estimate heritability.
# Fastbat seems to work quite well as well. It finds some genes that are not significant according to GREML, but they are all boarderline. Similarly, it will work for all genes, unlike SBayesR. In this example (GTEx v8) there is an SBayesR estimates for all bar one gene. However, when using the eQTLGen statistics many genes are not converging (possibly due to meta-analysis leading to mispecification), meaning there may be an advnatate to using a simpler method such as fastbat. There is probably a quicker way of running fastbat within R.
# I have now added mbat_combo. mbat combo seems to do slightly better. Improving overlap with GREML. For simplicity, I think we should go with mbat_combo.

```

</details>

<details><summary>Show SNP-h2 estimates across methods</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/h2_estimates.png)

LDSC estimates are very inaccurate and do not correlated well with other methods. SBayesR correlates best wit GREML, and SBayesR and SBayesR with robust setting are highly correlated. The SBayesS method correlates less well with other methods, but this doesn't mean it is inaccurate as we don't know the truth.

</details>

<details><summary>Show number of genes with significant SNP-h2</summary>

```{r, eval=T, echo=F}
n_gene<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/n_sig_hsq.csv')
kable(n_gene, rownames = FALSE)

```

The number is similar across methods, but SBayesR has the highest.

SBayesR has the largest overlap with GREML. Given this, and that SBayesR finds the most significant genes, I think we should use SBayesR without robust parameteristation to estimate heritability.

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8/n_sig_hsq.png)
Again LDSC is least concordant with other methods.

</details>

***

## Comparing predicted-observed expression in GTEx v8

Here we will predict gene expression levels in the GTEx v8 sample and then test the correlation with observed expression levels. Initially, we will use FUSION SNP-weights derived using the YFS whole blood sample, and eQTL data from eQTLGen whole blood meta-analysis (excl GTEx).

I do not have access to individual level data from GTeX v8, so this project is being carried out in collaboration with Zac Gerring. Here, I will prepare the SNP-weights and the code to predict gene expression levels for Zac. As an example target sample, I will use the EUR subset of the 1KG Phase 3 reference.

I have already written a script to predicted expression levels from TWAS weights called [FeaturePred](https://github.com/opain/Predicting-TWAS-features). 

***

### Generate SNP-weights from eQTLGen

****

#### Format eQTL sumstats

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
# Download the full cis-eQTL data exluding GTEx
# This was sent privately by Urmo Vosa
mkdir /users/k1806347/oliverpainfel/Data/eQTLGen/excl_GTEx

# Extract relevent columns
zcat /users/k1806347/oliverpainfel/Data/eQTLGen/excl_GTEx/2019-12-11-cis-eQTLsFDR-ProbeLevel-CohortInfoRemoved-WoGTEx.txt.gz | cut -f 1-5,9-11,13 | gzip > /users/k1806347/oliverpainfel/Data/eQTLGen/excl_GTEx/2019-12-11-cis-eQTLsFDR-ProbeLevel-CohortInfoRemoved-WoGTEx.small.txt.gz
```

```{r, eval=F, echo=T}
# conda activate /scratch/prj/oliverpainfel/Software/MyGit/GenoDisc/pipeline/.snakemake/conda/ed8111a468dc33bc018fdcd93683b72f
library(data.table)

# Read in relevent columns from the sumstats
sumstats<-fread('/users/k1806347/oliverpainfel/Data/eQTLGen/excl_GTEx/2019-12-11-cis-eQTLsFDR-ProbeLevel-CohortInfoRemoved-WoGTEx.small.txt.gz')

# Extract data for each gene
genes<-unique(sumstats$ProbeName)

# Read in EUR MAF
frq<-NULL
for(i in 1:22){
  frq<-rbind(frq, fread(paste0('/users/k1806347/oliverpainfel/Data/1KG/FUSION//1000G.EUR.',i,'.frq')))
}
names(frq)[names(frq) == 'MAF']<-'FREQ'

setkey(sumstats, ProbeName)
setkey(frq, SNP)

# Process eQTL sumstats for each gene
dir.create('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen')
for(i in 1:length(genes)){
  print(i)
  
  tmp<-sumstats[.(genes[i])]
  
  # Create A1 and A2 columns and update column names
  tmp$A1<-gsub('.*/','',tmp$SNPType)
  tmp$A2<-gsub('/.*','',tmp$SNPType)
  tmp$A2[tmp$A1 != tmp$AlleleAssessed]<-gsub('.*/','',tmp$SNPType[tmp$A1 != tmp$AlleleAssessed])
  tmp$A1[tmp$A1 != tmp$AlleleAssessed]<-gsub('/.*','',tmp$SNPType[tmp$A1 != tmp$AlleleAssessed])

  tmp<-tmp[,c('ProbeName','SNPName','SNPChr','SNPChrPos', 'A1', 'A2','PValue','OverallZScore','SumNumberOfSamples'), with=F]
  names(tmp)<-c('Gene','SNP','CHR','BP','A1','A2','P','Z','N')

  frq_tmp<-frq[.(tmp$SNP)]
  
  # Insert FREQ from EUR reference
  # There don't seem to be any strand flips
  tmp_match<-merge(tmp, frq_tmp[,c('SNP','A1','A2','FREQ'),with=F], by=c('SNP','A1','A2'))
  tmp_flip<-merge(tmp, frq_tmp[,c('SNP','A1','A2','FREQ'),with=F], by.x=c('SNP','A1','A2'), by.y=c('SNP','A2','A1'))
  tmp_flip$FREQ<-1-tmp_flip$FREQ
  tmp<-rbind(tmp_match, tmp_flip)
  
  # Approximate BETA, SE, and P
  tmp$P<-2*pnorm(-abs(tmp$Z))
  tmp$BETA<-tmp$Z/sqrt((2*tmp$FREQ)*(1-tmp$FREQ)*(tmp$N+(tmp$Z^2)))
  tmp$SE<-abs(tmp$BETA)/abs(tmp$Z)
  
  tmp$GENE<-genes[i]
    
  tmp<-tmp[,c('GENE','CHR','SNP','BP','A1','A2','BETA','SE','Z','P','FREQ','N'),with=F]
  
  if(i == 1){
    write.table(tmp, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen_sumstats_exclGTeX.txt', col.names=T, row.names=F, quote=F)
  } else {
    write.table(tmp, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen_sumstats_exclGTeX.txt', col.names=F, row.names=F, quote=F, append=T)
  }
}

```

</details>

***

#### Create TWAS weights

<details><summary>Show code</summary>

```{bash}
# Create a conda environment to run the eQTL_to_TWAS analysis
mamba env create -f env.yaml
conda activate eqtl_to_twas
Rscript -e 'remotes::install_github("tshmak/lassosum@v0.4.5")'
Rscript -e 'remotes::install_github("opain/GenoUtils@4beb75620f3291b633598acd06febb22298418c8")'
Rscript -e 'remotes::install_github("gabraham/plink2R@d74be015e8f54d662b96c6c2a52a614746f9030d", subdir="plink2R")'
```

```{bash, eval=F, echo=T}
# Create file listing GWAS that haven't been processed.
mkdir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights
cut -f 1 -d' ' /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen_sumstats_exclGTeX.txt | tail -n +2 | uniq > /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/gene_list.txt

> /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/todo.txt
for i in $(cat /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/gene_list.txt);do
  if [ ! -f /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/eQTLGen.eQTL/${i}.done ]; then
    echo ${i} >> /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/todo.txt
  fi
done

# Create shell script to run using sbatch
cat > /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/sbatch.sh << 'EOF'
#!/bin/sh

#SBATCH -p neurohack_cpu,cpu
#SBATCH --mem 10G
#SBATCH -n 1
#SBATCH --nodes 1
#SBATCH -J eQTL_to_TWAS
#SBATCH -t 10
#SBATCH --output=/dev/null
#SBATCH --error=/dev/null

source ~/miniconda3/etc/profile.d/conda.sh
conda activate eqtl_to_twas

# Use software and PGS method reference data downloaded for GenoPred v2.2.0

ID=$(awk -v var="$SLURM_ARRAY_TASK_ID" 'NR == var {print $1}' /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/todo.txt)

# Use 1kg reference data from GenoPred v2.0.0
Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/compute_weights.R \
	--id ${ID} \
	--extract /users/k1806347/oliverpainfel/Data/ldsc/w_hm3.snplist \
	--sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen_sumstats_exclGTeX.txt \
  --gcta /users/k1806347/oliverpainfel/Software/gcta_1.94.sh \
	--gctb /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/software/gctb/gctb_2.03beta_Linux/gctb \
	--gctb_ref /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr \
	--plink_ref_chr /users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/ref.chr \
	--plink_ref_keep /users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/keep_files/EUR.keep \
	--ld_blocks /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/ld_blocks/EUR \
  --rscript Rscript \
  --dbslmm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/software/dbslmm/software \
  --plink /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/software/plink/plink \
  --PRScs_path /users/k1806347/oliverpainfel/Software/PRScs.sh \
  --PRScs_ref_path /users/k1806347/oliverpainfel/Software/PRScs/ldblk_1kg_eur \
	--ldpred2_ref_dir /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/ldpred2_ref \
  --output /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/eQTLGen.eQTL

EOF

sbatch --array 1-$(wc -l /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/todo.txt | cut -d' ' -f1)%400 /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/sbatch.sh

```

```{R, echo=T, eval=F}
# Create .pos file
library(data.table)

# Read in list of RDat files
rdat_list<-list.files(path='/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/eQTLGen.eQTL', pattern='.RDat')

# Start making pos file
pos<-data.frame(PANEL='eQTLGen.eQTL',
                WGT=paste0('eQTLGen.eQTL/',rdat_list),
                ID=gsub('\\..*','',rdat_list))

# Insert CHR, P0 and P1 (GRCh=37)
library(biomaRt)
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
Genes<-getBM(attributes=c('ensembl_gene_id_version','chromosome_name','start_position','end_position'), mart = ensembl)
Genes$ensembl_gene_id_version<-gsub('\\..*','',Genes$ensembl_gene_id_version)
names(Genes)<-c('ID','CHR','P0','P1')
Genes<-Genes[complete.cases(Genes),]
Genes<-Genes[!duplicated(Genes),]

pos<-merge(pos, Genes, all.x=T, by='ID')

# Read in each RDat file to retrieve N
for(i in 1:nrow(pos)){
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/',pos$WGT[i]))
  pos$N[i]<-N.tot
  pos$CHR_pos[i]<-snps$V1[1]
}

pos<-pos[,c('PANEL','WGT','ID','CHR','P0','P1','N')]

write.table(pos, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/weights/eQTLGen.eQTL.pos', col.names=T, row.names=F, quote=F)

```

</details>

***

### Generate SNP-weights from YFS

FUSION only provide the N of the sample and the Z of each SNP for each gene. We can convert this to the required information using reference MAF, though using these approximations is not ideal. This may not be the best comparison since they are finish and there may therefore be MAF and LD mismatch with target sample. Though I assume FUSION developers restricted the analysis to those os EUR ancestry.

***

#### Format eQTL sumstats

<details><summary>Show code</summary>

```{bash}
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION
wget https://data.broadinstitute.org/alkesgroup/FUSION/WGT/YFS.BLOOD.RNAARR.tar.bz2
tar xjvf YFS.BLOOD.RNAARR.tar.bz2
rm YFS.BLOOD.RNAARR.tar.bz2
```

```{r}
# Insert PANEL column into YFS .pos
library(data.table)
pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos')
pos$PANEL<-'YFS.BLOOD.RNAARR'
pos<-pos[,c('PANEL',names(pos)[names(pos) != 'PANEL']), with=F]
write.table(pos, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos', col.names=T, row.names=F, quote=F)
```
```{r, echo=T, eval=F}
library(data.table)

# Read in the pos file
pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos')
pos$N<-1264

# Read in EUR MAF
frq<-NULL
for(i in 1:22){
  frq<-rbind(frq, fread(paste0('/users/k1806347/oliverpainfel/Data/1KG/FUSION//1000G.EUR.',i,'.frq')))
}
names(frq)[names(frq) == 'MAF']<-'FREQ'

setkey(frq, SNP)

for(i in 1:nrow(pos)){
  print(i)
  
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/',pos$WGT[i]))
  tmp<-data.table(cbind(snps, wgt.matrix[,which(colnames(wgt.matrix) == 'top1')]))
  names(tmp)<-c('CHR','SNP','POS','BP','A1','A2','Z')
  tmp$N<-pos$N[i]
  
  frq_tmp<-frq[.(tmp$SNP)]
  
  # Insert EUR MAF
  tmp_match<-merge(tmp, frq_tmp[,c('SNP','A1','A2','FREQ'),with=F], by=c('SNP','A1','A2'))
  tmp_flip<-merge(tmp, frq_tmp[,c('SNP','A1','A2','FREQ'),with=F], by.x=c('SNP','A1','A2'), by.y=c('SNP','A2','A1'))
  tmp_flip$FREQ<-1-tmp_flip$FREQ
  tmp<-rbind(tmp_match, tmp_flip)
  
  # Approximate BETA, SE, and P
  tmp$P<-2*pnorm(-abs(tmp$Z))
  tmp$BETA<-tmp$Z/sqrt((2*tmp$FREQ)*(1-tmp$FREQ)*(tmp$N+(tmp$Z^2)))
  tmp$SE<-abs(tmp$BETA)/abs(tmp$Z)
  
  tmp$GENE<-pos$ID[i]
    
  tmp<-tmp[,c('GENE','CHR','SNP','BP','A1','A2','BETA','SE','Z','P','FREQ','N'),with=F]
  
  if(i == 1){
    write.table(tmp, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt', col.names=T, row.names=F, quote=F)
  } else {
    write.table(tmp, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt', col.names=F, row.names=F, quote=F, append=T)
  }
}

```

</details>


#### Create TWAS weights

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
# Create file listing GWAS that haven't been processed.
mkdir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL
cut -f 1 -d' ' /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt | tail -n +2 | uniq > /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/gene_list.txt

> /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/todo.txt
for i in $(cat /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/gene_list.txt);do
  if [ ! -f /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL/${i}.done ]; then
    echo ${i} >> /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/todo.txt
  fi
done

# Create shell script to run using sbatch
cat > /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/sbatch.sh << 'EOF'
#!/bin/sh

#SBATCH -p neurohack_cpu,cpu
#SBATCH --mem 10G
#SBATCH -n 1
#SBATCH --nodes 1
#SBATCH -J eQTL_to_TWAS
#SBATCH -t 10
#SBATCH --output=/dev/null
#SBATCH --error=/dev/null

source ~/miniconda3/etc/profile.d/conda.sh
conda activate eqtl_to_twas

# Use software and PGS method reference data downloaded for GenoPred v2.2.0

ID=$(awk -v var="$SLURM_ARRAY_TASK_ID" 'NR == var {print $1}' /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/todo.txt)

# Use 1kg reference data from GenoPred v2.0.0
Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/compute_weights.R \
	--id ${ID} \
	--extract /users/k1806347/oliverpainfel/Data/ldsc/w_hm3.snplist \
	--sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt \
  --gcta /users/k1806347/oliverpainfel/Software/gcta_1.94.sh \
	--gctb /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/software/gctb/gctb_2.03beta_Linux/gctb \
	--gctb_ref /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/gctb_ref/ukbEURu_hm3_shrunk_sparse/ukbEURu_hm3_v3_50k_chr \
	--plink_ref_chr /users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/ref.chr \
	--plink_ref_keep /users/k1806347/oliverpainfel/Data/1KG/GenoPred/v2.0.0/keep_files/EUR.keep \
	--ld_blocks /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/ld_blocks/EUR \
  --rscript Rscript \
  --dbslmm /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/software/dbslmm/software \
  --plink /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/software/plink/plink \
  --PRScs_path /users/k1806347/oliverpainfel/Software/PRScs.sh \
  --PRScs_ref_path /users/k1806347/oliverpainfel/Software/PRScs/ldblk_1kg_eur \
	--ldpred2_ref_dir /scratch/prj/ukbiobank/usr/ollie_pain/GenoPredPipe/GenoPred/pipeline/resources/data/ldpred2_ref \
  --output /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL
EOF

sbatch --array 1-$(wc -l /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/todo.txt | cut -d' ' -f1)%400 /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/sbatch.sh

```

```{R, echo=T, eval=F}
# Create .pos file
library(data.table)

# Read in list of RDat files
rdat_list<-list.files(path='/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL', pattern='.RDat')

# Start making pos file
pos<-data.frame(PANEL='YFS.eQTL',
                WGT=paste0('YFS.eQTL/',rdat_list),
                ID=gsub('\\..*','',rdat_list))

# Insert CHR, P0 and P1 (GRCh=37)
library(biomaRt)
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
Genes<-getBM(attributes=c('external_gene_name','external_synonym','chromosome_name','start_position','end_position'), mart = ensembl)
names(Genes)<-c('ID','ID_2','CHR','P0','P1')
Genes<-Genes[!duplicated(Genes),]

# Rename TMEM256-PLSCR3 to PLSCR3 to match FUSION IDs
Genes$ID[Genes$ID == 'TMEM256-PLSCR3']<-'PLSCR3'

Genes_ID<-Genes[Genes$ID %in% pos$ID,]
Genes_ID_2<-Genes[Genes$ID_2 %in% pos$ID & !(Genes$ID_2 %in% Genes_ID$ID),]
Genes_ID_2$ID<-Genes_ID_2$ID_2
Genes<-rbind(Genes_ID,Genes_ID_2)
Genes$ID_2<-NULL

pos<-merge(pos, Genes, all.x=T, by='ID')
pos<-pos[order(pos$CHR),]
pos<-pos[!duplicated(pos$WGT),]

# Read in each RDat file to retrieve N
for(i in 1:nrow(pos)){
  load(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/',pos$WGT[i]))
  pos$N[i]<-N.tot
  pos$CHR_pos[i]<-snps$V1[1]
}

pos<-pos[,c('PANEL','WGT','ID','CHR','P0','P1','N')]

write.table(pos, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos', col.names=T, row.names=F, quote=F)

```

</details>

***

### Check correlation between predicted expression for YFS models

This is just a sanity check that the models are correlating as expected.

***

#### Predict expression in 1KG

***

##### YFS FUSION models

<details><summary>Show code</summary>

```{bash, eval=F, echo=T} 

sbatch -p neurohack_cpu,cpu --mem 30G -n 5 -t 200 --wrap="
source ~/miniconda3/etc/profile.d/conda.sh
conda activate feature_pred

Rscript /users/k1806347/oliverpainfel/Software/MyGit/Predicting-TWAS-features/FeaturePred.V2.0.R \
	--PLINK_prefix_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
	--ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
	--ref_maf /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
	--weights /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos \
	--weights_dir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION \
	--plink /users/k1806347/oliverpainfel/Software/plink1.9.sh \
	--n_cores 5 \
	--save_score T \
	--save_ref_expr T \
	--memory 10000 \
	--all_mod T \
	--pigz /users/k1806347/oliverpainfel/Software/pigz \
	--output /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS.BLOOD.RNAARR"

```

</details>

***

##### YFS eQTL models

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}

sbatch -p neurohack_cpu,cpu --mem 30G -n 5 -t 100 --wrap="
source ~/miniconda3/etc/profile.d/conda.sh
conda activate feature_pred

Rscript /users/k1806347/oliverpainfel/Software/MyGit/Predicting-TWAS-features/FeaturePred.V2.0.R \
	--PLINK_prefix_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
	--ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
	--ref_maf /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
	--weights /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos \
	--weights_dir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL \
	--plink /users/k1806347/oliverpainfel/Software/plink1.9.sh \
	--n_cores 5 \
	--save_score T \
	--save_ref_expr T \
	--memory 10000 \
	--all_mod T \
	--pigz /users/k1806347/oliverpainfel/Software/pigz \
	--output /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS.eQTL"

```

</details>

***

#### Check correlation

<details><summary>Show code</summary>

```{R, eval=F, echo=T}

library(data.table)
fusion<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS.BLOOD.RNAARR/FeaturePredictions_YFS.BLOOD.RNAARR.txt.gz')
eqtl<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS.eQTL/FeaturePredictions_YFS.eQTL.txt.gz')

genes<-unique(gsub('\\..*','',gsub('YFS.eQTL.','',names(eqtl)[-1:-2])))

both<-merge(fusion, eqtl, by=c('FID','IID'))

cor_res<-list()
for(i in genes){
  print(which(genes == i))
  tmp<-both[,grepl(paste0('\\.',i,'\\.'), names(both)), with=F]
  names(tmp)<-gsub('YFS.eQTL.RDat.','eqtl.',gsub('YFS.BLOOD.RNAARR.YFS.','twas.',gsub(paste0(i,'.'),'', names(tmp))))
  cor_res[[i]]<-cor(tmp, use='p')
}

# Check SNP-weight correlations
library(reshape2)
cor_res_melt<-melt(cor_res)
cor_res_melt$test<-paste0(cor_res_melt$Var1,'_',cor_res_melt$Var2)

saveRDS(cor_res_melt, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS_cor.rds')

cor_res_average <- NULL
for (i in unique(cor_res_melt$test)) {
  cor_res_average <- rbind(cor_res_average, 
                           data.frame(
                             test = i,
                             Mean = mean(cor_res_melt$value[cor_res_melt$test == i])))
}


library(ggplot2)
png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS_cor_plot_fusion.png', units='px', width=3000, height=5000, res=300)
ggplot(cor_res_melt[grepl('^twas', cor_res_melt$Var1),], aes(x=paste0(Var1,' vs. ',Var2), y=value)) +
  geom_boxplot() +
  coord_flip() +
  facet_grid(rows='Var1', scales = 'free_y')
dev.off()

library(ggplot2)
png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS_cor_plot_eqtl.png', units='px', width=3000, height=5000, res=300)
ggplot(cor_res_melt[grepl('^eqtl', cor_res_melt$Var1),], aes(x=paste0(Var1,' vs. ',Var2), y=value)) +
  geom_boxplot() +
  coord_flip() +
  facet_grid(rows='Var1', scales = 'free_y')
dev.off()

# Some of the correlation between the TWAS models and eQTL based models are strongly negative.
# Negative correlations are only present for sbayesr, sbayesr_robust, ldpred2, and lassosum. Perhaps I am doing something wrong?
# Filter genes by those with signal
eqtl_pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos')
w_dir<-'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/'
eqtl_sig<-NULL
for(i in 1:nrow(eqtl_pos)){
  load(paste0(w_dir, eqtl_pos$WGT[i]))
  eqtl_sig<-rbind(eqtl_sig,
                  data.frame(ID=eqtl_pos$ID[i],
                             hsq=hsq[1],
                             hsq.p=hsq.pv,
                             TopSNP_Pvalue=signal$TopSNP_Pvalue,
                             P_mBATcombo=signal$P_mBATcombo))
}

eqtl_sig_true<-eqtl_sig[eqtl_sig$TopSNP_Pvalue < 5e-8 | eqtl_sig$P_mBATcombo < 0.01,]
cor_res_melt_sig<-cor_res_melt[cor_res_melt$L1 %in% eqtl_sig_true$ID,]
cor_res_melt_enet<-cor_res_melt[cor_res_melt$Var1 == 'twas.enet',]
cor_res_melt_enet_neg<-cor_res_melt_enet[cor_res_melt_enet$value < -0.1, ]

data.frame(table(cor_res_melt_enet_neg$Var2))

#                   Var1 Freq
# 1            twas.blup    0
# 2           twas.bslmm    0
# 3           twas.lasso    0
# 4            twas.top1    0
# 5            twas.enet    0
# 6            eqtl.top1    0
# 7           eqtl.prscs    0
# 8         eqtl.sbayesr    8
# 9  eqtl.sbayesr_robust    2
# 10          eqtl.susie    0
# 11         eqtl.susie1    0
# 12         eqtl.dbslmm    0
# 13       eqtl.lassosum    9
# 14        eqtl.ldpred2   76

cor_res_melt_enet_neg[cor_res_melt_enet_neg$L1 %in% cor_res_melt_enet_neg$L1[duplicated(cor_res_melt_enet_neg$L1)],]

# COPS6 is negative for both lassosum and sbayesr
# Most are negative for ldpred2
# GRK6 is the most negative for ldpred2
# Nothing odd is going on. They are just getting it wrong sometimes
# Do a final check of the LDpred2 stuff
# Could filter models to r

# Maybe there is some weird LD structure or LD mismatch with the reference in that area (could use DENTIST to check)

```

</details>

<details><summary>Show correlation between SNP-weights from each method</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS2_cor_plot.png)

This is looking good. Everything is working as it should.

</details>

***

### Predict expression in GTEx v8

***

This will be run by Zac. I will send him the score files and reference expression, and fusion LD reference data. I don't know the file paths so I have just put file names.

***

#### For Zac

***

#### Prepare files for testing

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac

# Copy FUSION reference with allele frequency files
cp -r /users/k1806347/oliverpainfel/Data/1KG/FUSION/ ./

# Copy FUSION .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac
mkdir FUSION.YFS
cd FUSION.YFS

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR ./

# Copy eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac
mkdir eQTL.YFS
cd eQTL.YFS

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS.eQTL ./

# Copy pigz binary
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac
cp /users/k1806347/oliverpainfel/Software/pigz ./

# Copy plink binary
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac
cp /users/k1806347/oliverpainfel/Software/plink1.9/plink ./

# Copy FeaturePred.V2.0.R
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac
cp /users/k1806347/oliverpainfel/Software/MyGit/Predicting-TWAS-features/FeaturePred.V2.0.R ./

cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS
tar -zcvf for_zac.tar.gz for_zac

##########
# Make a new folder containing updated YFS and eQTLGen TWAS weights
##########

mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_26042022

# Copy YFS eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_26042022
mkdir eQTL.YFS
cd eQTL.YFS

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS.eQTL ./

# Copy eQTL-Gen eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_26042022
mkdir eQTL.eQTLGen
cd eQTL.eQTLGen

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen.eQTL ./

cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS
tar -zcvf for_zac_26042022.tar.gz for_zac_26042022


```

</details>

***

#### Prepare files for all genes

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_160622
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_160622

# Copy eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_160622
mkdir eQTL.YFS
cd eQTL.YFS

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFSall/YFS.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFSall/YFS.eQTL ./

rm YFS.eQTL/*.done

# Copy eQTL-Gen eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_160622
mkdir eQTL.eQTLGen
cd eQTL.eQTLGen

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall/eQTLGen.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall/eQTLGen.eQTL ./

rm eQTLGen.eQTL/*.done

cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS
tar -zcvf for_zac_160622.tar.gz for_zac_160622

```

</details>

***

#### Prepare files for all genes (update 300722)

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300722
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300722

# Copy eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300722
mkdir eQTL.YFS
cd eQTL.YFS

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFSall_300722/YFS.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFSall_300722/YFS.eQTL ./

rm YFS.eQTL/*.done

# Copy eQTL-Gen eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300722
mkdir eQTL.eQTLGen
cd eQTL.eQTLGen

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall_300722/eQTLGen.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall_300722/eQTLGen.eQTL ./

rm eQTLGen.eQTL/*.done

cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS
tar -zcvf for_zac_300722.tar.gz for_zac_300722

```

</details>

***

#### Prepare files for SuSiE test

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300922
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300922

# Copy eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300922
mkdir eQTL.YFS
cd eQTL.YFS

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFSall_SuSiE/YFS.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFSall_SuSiE/YFS.eQTL ./

rm YFS.eQTL/*.done

# Copy eQTL-Gen eQTL-based .pos, .Rdat files, score files, and reference expression
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac_300922
mkdir eQTL.eQTLGen
cd eQTL.eQTLGen

cp /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall_SuSiE/eQTLGen.eQTL.pos ./
cp -r /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall_SuSiE/eQTLGen.eQTL ./

rm eQTLGen.eQTL/*.done

cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS
tar -zcvf for_zac_300922.tar.gz for_zac_300922

```

</details>

***

#### FUSION YFS models

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}
cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac

Rscript FeaturePred.V2.0.R \
	--PLINK_prefix_chr LDREF/1000G.EUR. \
	--weights FUSION.YFS/YFS.BLOOD.RNAARR.pos \
	--weights_dir FUSION.YFS \
	--ref_ld_chr LDREF/1000G.EUR. \
	--plink ./plink \
	--n_cores 1 \
	--memory 10000 \
	--all_mod T \
	--pigz ./pigz \
	--ref_maf LDREF/1000G.EUR. \
	--output test/FUSION.YFS

```

</details>

***

#### YFS eQTL-based models

<details><summary>Show code</summary>

```{bash, eval=F, echo=T}

cd /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/for_zac

/users/k1806347/oliverpainfel/Software/Rscript.sh FeaturePred.V2.0.nodel2.R \
	--PLINK_prefix_chr LDREF/1000G.EUR. \
	--weights eQTL.YFS/YFS.eQTL.pos \
	--weights_dir eQTL.YFS \
	--ref_ld_chr LDREF/1000G.EUR. \
	--plink ./plink \
	--n_cores 1 \
	--memory 10000 \
	--all_mod T \
	--pigz ./pigz \
	--ref_maf LDREF/1000G.EUR. \
	--output test/eQTL.YFS

```

</details>

***

### Compare predicted and observed expression in GTEx v8

Zac now sends me the predicted expression data for GTEx v8 so I can compare predicted and observed expression. Observed expression in GTEx is publicly available. 

Here I am reading in observed and predicted expression values, testing their correlation, and then summarising the results across gene expression imputation methods. I am using the processed and normalised observed expression in GTEx. First I covary observed expression for covariates used in the original eQTL analysis by GTEx.

***

#### Evaluate FUSION and eQTL-based YFS models

<details><summary>Show code</summary>

```{r, eval=F, echo=T}
library(data.table)

# Read in the observed expression
obs<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/GTEx_Analysis_v8_eQTL_expression_matrices/Whole_Blood.v8.normalized_expression.bed.gz')

# Insert external_gene_name
obs<-obs[,-1:-3]
obs$gene_id<-gsub('\\..*','',obs$gene_id)

library(biomaRt)
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
Genes<-getBM(attributes=c('ensembl_gene_id_version','external_gene_name'), mart = ensembl)
Genes$ensembl_gene_id_version<-gsub('\\..*','',Genes$ensembl_gene_id_version)

obs<-merge(obs, Genes, by.x='gene_id', by.y='ensembl_gene_id_version')
obs<-obs[,c('external_gene_name',names(obs)[grepl('GTEX-', names(obs))]), with=F]
obs<-t(obs)
colnames(obs)<-obs[1,]
obs<-obs[-1,]
obs<-cbind(row.names(obs),obs)
colnames(obs)[1]<-'ID'
obs<-data.table(obs)
obs<-cbind(obs[,1],data.frame(lapply(obs[,-1], function(x) as.numeric(as.character(x)))))

# Read in covariates
covs<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/GTEx_Analysis_v8_eQTL_covariates/Whole_Blood.v8.covariates.txt')
covs<-t(covs)
colnames(covs)<-covs[1,]
covs<-covs[-1,]
covs<-cbind(row.names(covs),covs)
colnames(covs)[1]<-'ID'
covs<-data.table(covs)
covs<-cbind(covs[,1],data.frame(lapply(covs[,-1], function(x) as.numeric(as.character(x)))))

# Merge observed expression and covariates
obs<-obs[,!duplicated(names(obs)),with=F]
obs_covs<-merge(obs, covs, by='ID')

# Read in predicted expression
eqtl<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/Zac/030822/FeaturePredictions_YFS.eQTL.txt.gz')
names(eqtl)<-gsub('.RDat','',gsub('YFS.','', names(eqtl)))

fusion<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/Zac/FUSION.YFS/FeaturePredictions_YFS.BLOOD.RNAARR.txt.gz')
names(fusion)<-gsub('YFS.BLOOD.RNAARR.YFS.','fusion.', names(fusion))

# Identify genes available in fusion and eqtl based models
obs_genes<-names(obs)[-1]
eqtl_genes<-unique(gsub('\\..*','',gsub('eQTL.','',names(eqtl)[-1:-2])))
fusion_genes<-unique(gsub('\\..*','',gsub('fusion.','',names(fusion)[-1:-2])))
both_genes<-intersect(obs_genes, eqtl_genes)
both_genes<-intersect(both_genes, fusion_genes)

# Residualise the covariates
obs_resid<-data.frame(ID=obs_covs$ID, stringsAsFactors=F)
for(i in both_genes){
  obs_resid[[i]]<-as.numeric(scale(resid(lm(as.formula(paste0(i,' ~ ', paste(names(covs)[-1], collapse=' + '))), data=obs_covs))))
}
obs_resid<-data.table(obs_resid)

# Merge eqtl and fusion predicted expression
pred_exp<-merge(eqtl, fusion, by=c('FID','IID'))

# Calculate correlation between observed expression and predicted expression from each method
# Also, calculate the significance of differences between each model for each gene.
cor_res<-list()
for(i in both_genes){
  # Rename columns to make output consistent across genes and label the observed expression
  pred_exp_tmp<-pred_exp[,grepl(paste0('FID$|IID$|\\.',i,'\\.'), names(pred_exp)), with=F]
  names(pred_exp_tmp)<-gsub(paste0('.',i), '', names(pred_exp_tmp))
  
  obs_exp_tmp<-obs_resid[,c('ID',i), with=F]
  names(obs_exp_tmp)[names(obs_exp_tmp) == i]<-'obs'
  
  # merge predicted and observed expression
  both_exp_tmp<-merge(pred_exp_tmp, obs_exp_tmp, by.x='IID', by.y='ID')
  
  both_exp_tmp$obs<-as.numeric(both_exp_tmp$obs)

  # Calculate correlation
  cor_res[[i]]<-cor(both_exp_tmp[,-1:-2,with=F], use='p')
}

saveRDS(cor_res, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_YFS_full.RDS')

# melt and combine all the results
cor_res_melt<-reshape2::melt(cor_res)
cor_res_melt_obs<-cor_res_melt[cor_res_melt$Var1 == 'obs',]
cor_res_melt_obs<-cor_res_melt_obs[cor_res_melt_obs$Var1 != cor_res_melt_obs$Var2,]
cor_res_melt_obs$test<-paste0(cor_res_melt_obs$Var1,'_',cor_res_melt_obs$Var2)

fwrite(cor_res_melt, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_YFS_full.txt', quote=F, sep=' ', na='NA')
write.table(cor_res_melt_obs, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_YFS.txt', row.names=F, quote=F)

# cor_res_melt<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_YFS_full.txt')
# cor_res_melt_obs<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_YFS.txt')

cor_res_average<-NULL
for(i in unique(cor_res_melt_obs$test)){
  cor_res_average<-rbind(cor_res_average, data.frame(test=i,
                                                     Mean=mean(cor_res_melt_obs$value[cor_res_melt_obs$test == i])))
}

library(ggplot2)
bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_boxplot.png', units='px', width=1500, height=1000, res=300)
ggplot(cor_res_melt_obs, aes(x=paste0(Var1,' vs. ',Var2), y=value)) +
  geom_boxplot() +
  labs(x='Test', y='Correlation') +
  coord_flip()
dev.off()

# Make a pairs plot
library("ggplot2")
library("GGally") 

cor_res_melt_obs_unmelt<-dcast(data = cor_res_melt_obs,formula = L1~Var2,fun.aggregate = sum,value.var = "value")

cor_res_melt_obs_unmelt$negative

lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point() +
    geom_abline(intercept =0 , slope = 1, colour='red') +
    geom_vline(xintercept= 0, colour='blue') +
    geom_hline(yintercept= 0, colour='blue') +
    xlim(c(min(cor_res_melt_obs$value),max(cor_res_melt_obs$value)))+
    ylim(c(min(cor_res_melt_obs$value),max(cor_res_melt_obs$value)))
}  

diagfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_density() +
    geom_vline(xintercept= 0, colour='blue') +
    xlim(c(min(cor_res_melt_obs$value),max(cor_res_melt_obs$value)))
}  

bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_pairsplot.png', units='px', width=5000, height=5000, res=300)
ggpairs(cor_res_melt_obs_unmelt[,-1], lower = list(continuous = wrap(lowerfun)), diag = list(continuous = wrap(diagfun)))
dev.off()

# Count the number of genes with correlation > 0.1 for each method
n_valid<-NULL
for(i in unique(cor_res_melt_obs$Var2)){
  n_valid<-rbind(n_valid, data.frame(Method=i,
                                     N_valid=sum(cor_res_melt_obs$value[cor_res_melt_obs$Var2 == i] > 0.1, na.rm=T),
                                     median_cor=median(cor_res_melt_obs$value[cor_res_melt_obs$Var2 == i], na.rm=T)))
}
n_valid<-n_valid[order(-n_valid$N_valid),]
n_valid$Freq_valid<-n_valid$N_valid/length(unique(cor_res_melt_obs$L1))

# Also count the number of times each method performed best
cor_res_melt_obs_top<-cor_res_melt_obs[order(-cor_res_melt_obs$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top[!is.na(cor_res_melt_obs_top$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top[!duplicated(cor_res_melt_obs_top$L1),]

n_valid$N_top<-NA
n_valid$median_top<-NA
for(i in n_valid$Method){
  n_valid$N_top[n_valid$Method == i]<-sum(cor_res_melt_obs_top$test == paste0('obs_',i))
  n_valid$median_top[n_valid$Method == i]<-median(cor_res_melt_obs_top$value[cor_res_melt_obs_top$test == paste0('obs_',i)])
}

n_valid$Prop_top<-n_valid$N_top/sum(n_valid$N_top)

# Also count the number of times each sumstat method performed best
cor_res_melt_obs_ss<-cor_res_melt_obs[grepl('eQTL', cor_res_melt_obs$test),]
cor_res_melt_obs_ss<-cor_res_melt_obs_ss[!is.na(cor_res_melt_obs_ss$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_ss[order(-cor_res_melt_obs_ss$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top[!duplicated(cor_res_melt_obs_top$L1),]

n_valid$N_top_ss<-NA
n_valid$median_top_ss<-NA
for(i in n_valid$Method){
  n_valid$N_top_ss[n_valid$Method == i]<-sum(cor_res_melt_obs_top$test == paste0('obs_',i))
  n_valid$median_top_ss[n_valid$Method == i]<-median(cor_res_melt_obs_top$value[cor_res_melt_obs_top$test == paste0('obs_',i)])
}

n_valid$Prop_top_ss<-n_valid$N_top_ss/sum(n_valid$N_top_ss)

# Also count the number of times each sumstat method performed best
cor_res_melt_obs_top1<-cor_res_melt_obs[grepl('top1', cor_res_melt_obs$test),]
cor_res_melt_obs_top1<-cor_res_melt_obs_top1[!is.na(cor_res_melt_obs_top1$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top1[order(-cor_res_melt_obs_top1$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top[!duplicated(cor_res_melt_obs_top$L1),]

n_valid$N_top_top1<-NA
n_valid$median_top_top1<-NA
for(i in n_valid$Method){
  n_valid$N_top_top1[n_valid$Method == i]<-sum(cor_res_melt_obs_top$test == paste0('obs_',i))
  n_valid$median_top_top1[n_valid$Method == i]<-median(cor_res_melt_obs_top$value[cor_res_melt_obs_top$test == paste0('obs_',i)])
}

n_valid$Prop_top_top1<-n_valid$N_top_top1/sum(n_valid$N_top_top1)

write.csv(n_valid, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/n_valid.csv', row.names=F)

# Read in reported R2 by weights
yfs.profile<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.profile')

################
# Report the number of times each method does significantly better than the next best method across genes
################

cor_res_melt<-reshape2::melt(cor_res)
cor_res_melt_eqtl<-cor_res_melt[grepl('eQTL|obs',cor_res_melt$Var1) & grepl('eQTL|obs',cor_res_melt$Var2),]

library(psych)

cor_res_melt_eqtl_i_obs_diff_all<-NULL
for(i in unique(cor_res_melt_eqtl$L1)){
  cor_res_melt_eqtl_i<-cor_res_melt_eqtl[cor_res_melt_eqtl$L1 == i,]
  cor_res_melt_eqtl_i_obs<-cor_res_melt_eqtl_i[cor_res_melt_eqtl_i$Var1 == 'obs',]
  cor_res_melt_eqtl_i_noobs<-cor_res_melt_eqtl_i[cor_res_melt_eqtl_i$Var1 != 'obs' & cor_res_melt_eqtl_i$Var2 != 'obs',]
  
  cor_res_melt_eqtl_i_obs_2<-merge(cor_res_melt_eqtl_i_obs, cor_res_melt_eqtl_i_noobs, by=c('L1','Var2'))
  cor_res_melt_eqtl_i_obs_3<-merge(cor_res_melt_eqtl_i_obs_2, cor_res_melt_eqtl_i_obs_2, by.x=c('L1','Var2'), by.y=c('L1','Var1.y'))
  
  cor_res_melt_eqtl_i_obs_3<-cor_res_melt_eqtl_i_obs_3[,c('L1','Var2','Var1.x.x','value.x.x','Var2.y','value.x.y','value.y.y')]
  names(cor_res_melt_eqtl_i_obs_3)<-c('ID','z','x','xz','y','xy','yz')
  cor_res_melt_eqtl_i_obs_3<-cor_res_melt_eqtl_i_obs_3[,c('ID','x','z','y','xz','xy','yz')]
  
  cor_res_melt_eqtl_i_obs_3<-cor_res_melt_eqtl_i_obs_3[cor_res_melt_eqtl_i_obs_3$z != cor_res_melt_eqtl_i_obs_3$y,]
  cor_res_melt_eqtl_i_obs_3<-cor_res_melt_eqtl_i_obs_3[!duplicated(cor_res_melt_eqtl_i_obs_3),]

  cor_res_melt_eqtl_i_obs_3$n<-nrow(pred_exp)
  
  cor_res_melt_eqtl_i_obs_3$yz_diff<-cor_res_melt_eqtl_i_obs_3$xz - cor_res_melt_eqtl_i_obs_3$xy
  
  cor_res_melt_eqtl_i_obs_3$yz_diff_p<-apply(cor_res_melt_eqtl_i_obs_3[,c('xz','xy','yz','n')], 1, function(y) paired.r(xy=y['xy'], xz=y['xz'], yz=y['yz'], n=y['n'], twotailed=T)$p[1])

  cor_res_melt_eqtl_i_obs_diff_all<-rbind(cor_res_melt_eqtl_i_obs_diff_all, cor_res_melt_eqtl_i_obs_3)

}

# Count the number of times each z does better than y
cor_res_melt_eqtl_i_obs_diff_all_count<-list()
for(i in unique(cor_res_melt_eqtl_i_obs_diff_all$z)){
  tmp<-cor_res_melt_eqtl_i_obs_diff_all[cor_res_melt_eqtl_i_obs_diff_all$z == i,]
  tmp<-tmp[tmp$xz > tmp$xy & tmp$yz_diff_p < 0.05,]
  
  tmp_count<-data.frame(table(tmp$y))
  names(tmp_count)<-c('Ref',i)
  
  cor_res_melt_eqtl_i_obs_diff_all_count[[i]]<-tmp_count
  
}

cor_res_melt_eqtl_i_obs_diff_all_count_tab<-Reduce(function(dtf1, dtf2) merge(dtf1, dtf2, by = "Ref", all.x = TRUE),
        cor_res_melt_eqtl_i_obs_diff_all_count)

fwrite(cor_res_melt_eqtl_i_obs_diff_all_count_tab, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/yfs_method_better_than_other.csv', quote=T, na='NA')

# Count the number of times a z does better than all other models for a given gene
cor_res_melt_eqtl_i_obs_diff_all_eqtl<-cor_res_melt_eqtl_i_obs_diff_all[grepl('eQTL',cor_res_melt_eqtl_i_obs_diff_all$z) & grepl('eQTL',cor_res_melt_eqtl_i_obs_diff_all$y),]
cor_res_melt_eqtl_i_obs_diff_all_sig_best<-NULL
for(i in unique(cor_res_melt_eqtl_i_obs_diff_all_eqtl$z)){
  tmp<-cor_res_melt_eqtl_i_obs_diff_all_eqtl[cor_res_melt_eqtl_i_obs_diff_all_eqtl$z == i,]
  tmp2<-aggregate(tmp$xy, list(tmp$ID), FUN=max)
  tmp3<-merge(tmp,tmp2, by.x=c('ID','xy'), by.y=c('Group.1','x'))
  tmp3<-tmp3[!duplicated(tmp3$ID),]
  
  tmp3<-tmp3[which(tmp3$xz > tmp3$xy & tmp3$yz_diff_p < 0.05),]

  tmp_count<-data.frame(Model=i,
                        N_best=nrow(tmp3),
                        N_best_by_10=nrow(tmp3[abs(tmp3$yz_diff) > 0.10, ]),
                        N_best_by_05=nrow(tmp3[abs(tmp3$yz_diff) > 0.05, ]),
                        N_best_by_02=nrow(tmp3[abs(tmp3$yz_diff) > 0.02, ]),
                        N_best_by_01=nrow(tmp3[abs(tmp3$yz_diff) > 0.01, ]))
  
  cor_res_melt_eqtl_i_obs_diff_all_sig_best<-rbind(cor_res_melt_eqtl_i_obs_diff_all_sig_best, tmp_count)
}

fwrite(cor_res_melt_eqtl_i_obs_diff_all_sig_best, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/yfs_method_better_than_all.csv', quote=T, na='NA')

# Count the number of times the top1 model is significantly worse
cor_res_melt_eqtl_i_obs_diff_all_eqtl<-cor_res_melt_eqtl_i_obs_diff_all[grepl('eQTL',cor_res_melt_eqtl_i_obs_diff_all$z) & grepl('eQTL',cor_res_melt_eqtl_i_obs_diff_all$y),]
cor_res_melt_eqtl_i_obs_diff_all_sig_eqtl_worse<-NULL
for(i in 'eQTL.top1'){
  tmp<-cor_res_melt_eqtl_i_obs_diff_all_eqtl[cor_res_melt_eqtl_i_obs_diff_all_eqtl$z == i,]
  tmp2<-aggregate(tmp$xy, list(tmp$ID), FUN=max)
  tmp3<-merge(tmp,tmp2, by.x=c('ID','xy'), by.y=c('Group.1','x'))
  tmp3<-tmp3[!duplicated(tmp3$ID),]
  
  tmp3<-tmp3[which(tmp3$xz < tmp3$xy & tmp3$yz_diff_p < 0.05),]

  tmp_count<-data.frame(Model=i,
                        N_worst=nrow(tmp3),
                        N_worst_by_10=nrow(tmp3[abs(tmp3$yz_diff) > 0.10, ]),
                        N_worst_by_05=nrow(tmp3[abs(tmp3$yz_diff) > 0.05, ]),
                        N_worst_by_02=nrow(tmp3[abs(tmp3$yz_diff) > 0.02, ]),
                        N_worst_by_01=nrow(tmp3[abs(tmp3$yz_diff) > 0.01, ]))
  
  cor_res_melt_eqtl_i_obs_diff_all_sig_eqtl_worse<-rbind(cor_res_melt_eqtl_i_obs_diff_all_sig_eqtl_worse, tmp_count)
}

fwrite(cor_res_melt_eqtl_i_obs_diff_all_sig_eqtl_worse, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/yfs_eqtl_worst_than_best.csv', quote=T, na='NA')

```

</details>

<details><summary>Show correlation between observed and predicted expression</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_boxplot.png)

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_pairsplot.png)

```{r, eval=T, echo=F}
n_valid<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/n_valid.csv')
kable(n_valid, rownames = FALSE)

```

The correlations are very low compared the R2 reported in the FUSION profile. This is true when using fusion or eQTL based models. Is this due to poor generalisablity across YFS and GTEx?

</details>

***

#### Evaluate eQTLGen derived models

<details><summary>Show code</summary>

```{r, eval=F, echo=T}
library(data.table)

# Read in the observed expression
obs<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/GTEx_Analysis_v8_eQTL_expression_matrices/Whole_Blood.v8.normalized_expression.bed.gz')

# Insert external_gene_name
obs<-obs[,-1:-3]
obs$gene_id<-gsub('\\..*','',obs$gene_id)

obs<-t(obs)
colnames(obs)<-obs[1,]
obs<-obs[-1,]
obs<-cbind(row.names(obs),obs)
colnames(obs)[1]<-'ID'
obs<-data.table(obs)
obs<-cbind(obs[,1],data.frame(lapply(obs[,-1], function(x) as.numeric(as.character(x)))))

# Read in covariates
covs<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/GTEx_Analysis_v8_eQTL_covariates/Whole_Blood.v8.covariates.txt')
covs<-t(covs)
colnames(covs)<-covs[1,]
covs<-covs[-1,]
covs<-cbind(row.names(covs),covs)
colnames(covs)[1]<-'ID'
covs<-data.table(covs)
covs<-cbind(covs[,1],data.frame(lapply(covs[,-1], function(x) as.numeric(as.character(x)))))

# Merge observed expression and covariates
obs<-obs[,!duplicated(names(obs)),with=F]
obs_covs<-merge(obs, covs, by='ID')

# Read in predicted expression
eqtl<-fread('/users/k1806347/oliverpainfel/Data/GTeX/v8/Zac/030822/FeaturePredictions_eQTLGen.eQTL.txt.gz')
names(eqtl)<-gsub('.RDat','',gsub('eQTLGen.','', names(eqtl)))

# Identify genes available in fusion and eqtl based models
obs_genes<-names(obs)[-1]
eqtl_genes<-unique(gsub('\\..*','',gsub('eQTL.','',names(eqtl)[-1:-2])))
both_genes<-intersect(obs_genes, eqtl_genes)

# Residualise the covariates
obs_resid<-data.frame(ID=obs_covs$ID, stringsAsFactors=F)
for(i in both_genes){
  obs_resid[[i]]<-as.numeric(scale(resid(lm(as.formula(paste0(i,' ~ ', paste(names(covs)[-1], collapse=' + '))), data=obs_covs))))
}
obs_resid<-data.table(obs_resid)

# Calculate correlation between observed expression and predicted expression from each method
cor_res<-list()
for(i in both_genes){
  # Rename columns to make output consistent across genes and label the observed expression
  pred_exp_tmp<-eqtl[,grepl(paste0('FID$|IID$|\\.',i,'\\.'), names(eqtl)), with=F]
  names(pred_exp_tmp)<-gsub(paste0('.',i), '', names(pred_exp_tmp))
  
  obs_exp_tmp<-obs_resid[,c('ID',i), with=F]
  names(obs_exp_tmp)[names(obs_exp_tmp) == i]<-'obs'
  
  # merge predicted and observed expression
  both_exp_tmp<-merge(pred_exp_tmp, obs_exp_tmp, by.x='IID', by.y='ID')
  
  both_exp_tmp$obs<-as.numeric(both_exp_tmp$obs)

  # Calculate correlation
  cor_res[[i]]<-cor(both_exp_tmp[,-1:-2,with=F], use='p')
}

# melt and combine all the results
cor_res_melt<-reshape2::melt(cor_res)
cor_res_melt_obs<-cor_res_melt[cor_res_melt$Var1 == 'obs',]
cor_res_melt_obs<-cor_res_melt_obs[cor_res_melt_obs$Var1 != cor_res_melt_obs$Var2,]
cor_res_melt_obs$test<-paste0(cor_res_melt_obs$Var1,'_',cor_res_melt_obs$Var2)

fwrite(cor_res_melt, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_full.txt', sep=' ', quote=F, na='NA')

write.table(cor_res_melt_obs, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor.txt', row.names=F, quote=F)

# cor_res_melt<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_full.txt')
# cor_res_melt_obs<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor.txt')


cor_res_average<-NULL
for(i in unique(cor_res_melt_obs$test)){
  cor_res_average<-rbind(cor_res_average, data.frame(test=i,
                                                     Mean=mean(cor_res_melt_obs$value[cor_res_melt_obs$test == i]),
                                                     N=sum(cor_res_melt_obs$test == i)))
}

library(ggplot2)
bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_boxplot_eQTLGen.png', units='px', width=1500, height=1000, res=300)
ggplot(cor_res_melt_obs, aes(x=paste0(Var1,' vs. ',Var2), y=value)) +
  geom_boxplot() +
  labs(x='Test', y='Correlation') +
  coord_flip()
dev.off()

# Make a pairs plot
library("ggplot2")
library("GGally") 

cor_res_melt_obs_unmelt<-dcast(data = cor_res_melt_obs,formula = L1~Var2,fun.aggregate = sum,value.var = "value")

# Set values that equal 0 to NA as these represent missing data
cor_res_melt_obs_unmelt[cor_res_melt_obs_unmelt == 0]<-NA

lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point() +
    geom_abline(intercept =0 , slope = 1, colour='red') +
    geom_vline(xintercept= 0, colour='blue') +
    geom_hline(yintercept= 0, colour='blue') +
    xlim(c(min(cor_res_melt_obs$value),max(cor_res_melt_obs$value)))+
    ylim(c(min(cor_res_melt_obs$value),max(cor_res_melt_obs$value)))
}  

diagfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_density() +
    geom_vline(xintercept= 0, colour='blue') +
    xlim(c(min(cor_res_melt_obs$value),max(cor_res_melt_obs$value)))
}  

bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_pairsplot_eQTLGen.png', units='px', width=3000, height=3000, res=300)
ggpairs(cor_res_melt_obs_unmelt[,-1], lower = list(continuous = wrap(lowerfun)), diag = list(continuous = wrap(diagfun)))
dev.off()

# Count the number of genes with correlation > 0.1 for each method
n_valid<-NULL
for(i in unique(cor_res_melt_obs$Var2)){
  n_valid<-rbind(n_valid, data.frame(Method=i,
                                     N_valid=sum(cor_res_melt_obs$value[cor_res_melt_obs$Var2 == i] > 0.1, na.rm=T),
                                     median_cor=median(cor_res_melt_obs$value[cor_res_melt_obs$Var2 == i], na.rm=T)))
}
n_valid<-n_valid[order(-n_valid$N_valid),]
n_valid$Freq_valid<-n_valid$N_valid/length(unique(cor_res_melt_obs$L1))

# Also count the number of times each method performed best
cor_res_melt_obs_top<-cor_res_melt_obs[order(-cor_res_melt_obs$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top[!is.na(cor_res_melt_obs_top$value),]
cor_res_melt_obs_top<-cor_res_melt_obs_top[!duplicated(cor_res_melt_obs_top$L1),]

n_valid$N_top<-NA
n_valid$median_top<-NA
for(i in n_valid$Method){
  n_valid$N_top[n_valid$Method == i]<-sum(cor_res_melt_obs_top$test == paste0('obs_',i))
  n_valid$median_top[n_valid$Method == i]<-median(cor_res_melt_obs_top$value[cor_res_melt_obs_top$test == paste0('obs_',i)])
}

n_valid$Prop_top<-n_valid$N_top/sum(n_valid$N_top)

write.csv(n_valid, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/n_valid_eQTLGen.csv', row.names=F)

################
# Report the number of times each method does significantly better than the next best method across genes
################

library(psych)

cor_res_melt_i_obs_diff_all<-NULL
for(i in unique(cor_res_melt$L1)){
  cor_res_melt_i<-cor_res_melt[cor_res_melt$L1 == i,]
  cor_res_melt_i_obs<-cor_res_melt_i[cor_res_melt_i$Var1 == 'obs',]
  cor_res_melt_i_noobs<-cor_res_melt_i[cor_res_melt_i$Var1 != 'obs' & cor_res_melt_i$Var2 != 'obs',]
  
  cor_res_melt_i_obs_2<-merge(cor_res_melt_i_obs, cor_res_melt_i_noobs, by=c('L1','Var2'))
  cor_res_melt_i_obs_3<-merge(cor_res_melt_i_obs_2, cor_res_melt_i_obs_2, by.x=c('L1','Var2'), by.y=c('L1','Var1.y'))
  
  cor_res_melt_i_obs_3<-cor_res_melt_i_obs_3[,c('L1','Var2','Var1.x.x','value.x.x','Var2.y','value.x.y','value.y.y')]
  names(cor_res_melt_i_obs_3)<-c('ID','z','x','xz','y','xy','yz')
  cor_res_melt_i_obs_3<-cor_res_melt_i_obs_3[,c('ID','x','z','y','xz','xy','yz')]
  
  cor_res_melt_i_obs_3<-cor_res_melt_i_obs_3[cor_res_melt_i_obs_3$z != cor_res_melt_i_obs_3$y,]
  cor_res_melt_i_obs_3<-cor_res_melt_i_obs_3[!duplicated(cor_res_melt_i_obs_3),]

  cor_res_melt_i_obs_3$n<-nrow(obs_resid)
  
  cor_res_melt_i_obs_3$yz_diff<-cor_res_melt_i_obs_3$xz - cor_res_melt_i_obs_3$xy
  
  cor_res_melt_i_obs_3$yz_diff_p<-apply(cor_res_melt_i_obs_3[,c('xz','xy','yz','n')], 1, function(y) paired.r(xy=y['xy'], xz=y['xz'], yz=y['yz'], n=y['n'], twotailed=T)$p[1])

  cor_res_melt_i_obs_diff_all<-rbind(cor_res_melt_i_obs_diff_all, cor_res_melt_i_obs_3)

}

# Count the number of times each z does better than y
cor_res_melt_i_obs_diff_all_count<-list()
for(i in unique(cor_res_melt_i_obs_diff_all$z)){
  tmp<-cor_res_melt_i_obs_diff_all[cor_res_melt_i_obs_diff_all$z == i,]
  tmp<-tmp[tmp$xz > tmp$xy & tmp$yz_diff_p < 0.05,]
  
  tmp_count<-data.frame(table(tmp$y))
  names(tmp_count)<-c('Ref',i)
  
  cor_res_melt_i_obs_diff_all_count[[i]]<-tmp_count
  
}

cor_res_melt_i_obs_diff_all_count_tab<-Reduce(function(dtf1, dtf2) merge(dtf1, dtf2, by = "Ref", all.x = TRUE),
        cor_res_melt_i_obs_diff_all_count)

fwrite(cor_res_melt_i_obs_diff_all_count_tab, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/eqtlgen_method_better_than_other.csv', quote=T, na='NA')

# Count the number of times a z does better than all other models for a given gene
cor_res_melt_i_obs_diff_all_eqtl<-cor_res_melt_i_obs_diff_all[grepl('eQTL',cor_res_melt_i_obs_diff_all$z) & grepl('eQTL',cor_res_melt_i_obs_diff_all$y),]
cor_res_melt_i_obs_diff_all_sig_best<-NULL
for(i in unique(cor_res_melt_i_obs_diff_all_eqtl$z)){
  tmp<-cor_res_melt_i_obs_diff_all_eqtl[cor_res_melt_i_obs_diff_all_eqtl$z == i,]
  tmp2<-aggregate(tmp$xy, list(tmp$ID), FUN=max)
  tmp3<-merge(tmp,tmp2, by.x=c('ID','xy'), by.y=c('Group.1','x'))
  tmp3<-tmp3[!duplicated(tmp3$ID),]
  
  tmp3<-tmp3[which(tmp3$xz > tmp3$xy & tmp3$yz_diff_p < 0.05),]

  tmp_count<-data.frame(Model=i,
                        N_best=nrow(tmp3),
                        N_best_by_10=nrow(tmp3[abs(tmp3$yz_diff) > 0.10, ]),
                        N_best_by_05=nrow(tmp3[abs(tmp3$yz_diff) > 0.05, ]),
                        N_best_by_02=nrow(tmp3[abs(tmp3$yz_diff) > 0.02, ]),
                        N_best_by_01=nrow(tmp3[abs(tmp3$yz_diff) > 0.01, ]))
  
  cor_res_melt_i_obs_diff_all_sig_best<-rbind(cor_res_melt_i_obs_diff_all_sig_best, tmp_count)
}

fwrite(cor_res_melt_i_obs_diff_all_sig_best, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/eqtlgen_method_better_than_all.csv', quote=T, na='NA')

# Count the number of times the top1 model is significantly worse
cor_res_melt_i_obs_diff_all_eqtl<-cor_res_melt_i_obs_diff_all[grepl('eQTL',cor_res_melt_i_obs_diff_all$z) & grepl('eQTL',cor_res_melt_i_obs_diff_all$y),]
cor_res_melt_i_obs_diff_all_sig_eqtl_worse<-NULL
for(i in 'eQTL.top1'){
  tmp<-cor_res_melt_i_obs_diff_all_eqtl[cor_res_melt_i_obs_diff_all_eqtl$z == i,]
  tmp2<-aggregate(tmp$xy, list(tmp$ID), FUN=max)
  tmp3<-merge(tmp,tmp2, by.x=c('ID','xy'), by.y=c('Group.1','x'))
  tmp3<-tmp3[!duplicated(tmp3$ID),]
  
  tmp3<-tmp3[which(tmp3$xz < tmp3$xy & tmp3$yz_diff_p < 0.05),]

  tmp_count<-data.frame(Model=i,
                        N_worst=nrow(tmp3),
                        N_worst_by_10=nrow(tmp3[abs(tmp3$yz_diff) > 0.10, ]),
                        N_worst_by_05=nrow(tmp3[abs(tmp3$yz_diff) > 0.05, ]),
                        N_worst_by_02=nrow(tmp3[abs(tmp3$yz_diff) > 0.02, ]),
                        N_worst_by_01=nrow(tmp3[abs(tmp3$yz_diff) > 0.01, ]))
  
  cor_res_melt_i_obs_diff_all_sig_eqtl_worse<-rbind(cor_res_melt_i_obs_diff_all_sig_eqtl_worse, tmp_count)
}

fwrite(cor_res_melt_i_obs_diff_all_sig_eqtl_worse, '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/eqtlgen_eqtl_worst_than_best.csv', quote=T, na='NA')

```

</details>

<details><summary>Show correlation between observed and predicted expression</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_boxplot_eQTLGen.png)

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_pairsplot_eQTLGen.png)

```{r, eval=T, echo=F}
n_valid<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/n_valid_eQTLGen.csv')
kable(n_valid, rownames = FALSE)

```

The predicted-observed correlation is looking better here, with 87% of genes achieving a correlation > 0.1. However, the order of the methods has changed a bit, with top1 and SBayesR (in robust mode) performing best. I am not going to read into the order of methods until we have run across all genes. Note. SuSiE does not converge due to LD reference mismatch leading to many genes not being imputed using SuSiE.

</details>

***

#### Comparison of FUSION YFS and eQTLGen models 

```{r, eval=F, echo=T}

library(data.table)

# Read in pred_obs_cor for YFS and eQTLGen
eqtlgen<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor.txt')
yfs<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_YFS.txt')

# Subset YFS models from fusion
yfs<-yfs[grepl('fusion',yfs$Var2),]

# Compare number of (valid) genes from YFS and eQTLGen
length(unique(eqtlgen$L1)) # 16719
length(unique(yfs$L1)) # 4633

length(unique(eqtlgen$L1[eqtlgen$value > 0.1])) # 3800
length(unique(yfs$L1[yfs$value > 0.1])) # 1311

# Subset genes available in both fusion YFS and eQTLGen
library(biomaRt)
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=37)
Genes<-getBM(attributes=c('ensembl_gene_id','external_gene_name'), mart = ensembl)
eqtlgen<-merge(eqtlgen, Genes, by.x='L1', by.y='ensembl_gene_id')
eqtlgen$L1<-eqtlgen$external_gene_name

eqtlgen_subset<-eqtlgen[eqtlgen$L1 %in% yfs$L1,]
yfs_subset<-yfs[yfs$L1 %in% eqtlgen$L1,]

# Compare R for best eQTLGen model to best FUSION YFS model
eqtlgen_subset<-eqtlgen_subset[order(-eqtlgen_subset$value),]
eqtlgen_subset<-eqtlgen_subset[!is.na(eqtlgen_subset$value),]
eqtlgen_subset<-eqtlgen_subset[!duplicated(eqtlgen_subset$L1),]
yfs_subset<-yfs_subset[order(-yfs_subset$value),]
yfs_subset<-yfs_subset[!is.na(yfs_subset$value),]
yfs_subset<-yfs_subset[!duplicated(yfs_subset$L1),]

both_best<-merge(eqtlgen_subset, yfs_subset, by='L1')
nrow(both_best) # 4606
median(both_best$value.x) # 0.07559274
median(both_best$value.y) # 0.0630884

both_best_melt<-melt(both_best[,c('L1','value.x','value.y'),with=F])
names(both_best_melt)<-c('ID','Sample','R')
both_best_melt$Sample<-ifelse(both_best_melt$Sample == 'value.x', 'eQTLGen','YFS')
both_best_melt$Sample<-factor(both_best_melt$Sample, levels=c('YFS','eQTLGen'))
both_best_melt$R_rank<-rank(both_best_melt$R)

both_best_melt<-both_best_melt[complete.cases(both_best_melt),]

wilcox.test(R ~ Sample, data=both_best_melt) 
cor.test(x=both_best_melt$R, y=as.numeric(both_best_melt$Sample), method="spearman")

library(ggplot2)
library(cowplot)

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_eQTLGen_YFS_comp.png', units='px', width=1500, height=1500, res=300)

ggplot(both_best, aes(x=value.x, y=value.y)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, colour='red') +
  geom_vline(xintercept= 0, colour='blue') +
  geom_hline(yintercept= 0, colour='blue') +
  coord_fixed() +
  theme_half_open() +
  background_grid() +
  labs(x="R (eQTLGen)", y="R (FUSION YFS)")

dev.off()

# Look at distribution of R for best model for genes not in YFS
eqtlgen_not_in_yfs<-eqtlgen[!(eqtlgen$L1 %in% yfs$L1),]
eqtlgen_not_in_yfs<-eqtlgen_not_in_yfs[!is.na(eqtlgen_not_in_yfs$value),]
eqtlgen_not_in_yfs<-eqtlgen_not_in_yfs[!duplicated(eqtlgen_not_in_yfs$L1),]

eqtlgen_not_in_yfs$YFS<-F
eqtlgen_subset$YFS<-T

eqtlgen_comp_plot<-rbind(eqtlgen_not_in_yfs, eqtlgen_subset)

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/present_in_YFS_hist.png', units='px', width=1500, height=1000, res=300)

ggplot(eqtlgen_comp_plot, aes(x=value, fill=YFS, colour=YFS)) +
  geom_histogram(position="identity", alpha=0.5) +
  theme_half_open() +
  background_grid() +
  labs(x='R', fill = 'In YFS', colour='In YFS')

dev.off()

# Make the same plot but restricted to genes with mBAT-combo or sig eQTL
mbat_res<-NULL
for(i in 1:22){
  mbat_res<-rbind(mbat_res, fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen_exclGTEx.mbat.combo.chr',i,'.res.txt')))
}

# Check results in relation to fastbat
sum(!(is.na(mbat_res$P_fastBAT) & is.na(mbat_res$TopSNP_Pvalue))) # 19214
mbat_res$P_fastBAT.FDR<-p.adjust(mbat_res$P_fastBAT, method='fdr')
# Restrict to genes with either FDR sig gene association or gneome-wide sig eQTL
mbat_res<-merge(mbat_res, Genes, by.x='Gene', by.y='ensembl_gene_id')
fastbat_res_sig<-mbat_res[mbat_res$P_fastBAT.FDR < 0.05 | mbat_res$TopSNP_Pvalue < 5e-8,]
nrow(fastbat_res_sig) # 16540

eqtlgen_comp_plot_mbat<-eqtlgen_comp_plot[eqtlgen_comp_plot$L1 %in% fastbat_res_sig$external_gene_name,]

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/present_in_YFS_hist_sigsig.png', units='px', width=1500, height=1000, res=300)

ggplot(eqtlgen_comp_plot_mbat, aes(x=value, fill=YFS, colour=YFS)) +
  geom_histogram(position="identity", alpha=0.5) +
  theme_half_open() +
  background_grid() +
  labs(x='R', fill = 'In YFS', colour='In YFS')

dev.off()

# Subsetting to genes with sig mbat or eQTL doesn't change the figure much. Leave as is.

```

<details><summary>Show eQTLGen and FUSION YFS comparison</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor_eQTLGen_YFS_comp.png)

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/present_in_YFS_hist.png)

</details>

***

# Pseudovalidation

## FUSION

### YFS FUSION

```{bash, echo=T, eval=F}
mkdir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo
conda activate eqtl_to_twas
for chr in $(seq 1 22); do
  sbatch -p neurohack_cpu,cpu -t 10 --mem 10G --wrap="
  Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/fusion_pseudoval.R \
    --sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt \
    --weights /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos \
    --weights_dir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION \
    --ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION//1000G.EUR. \
    --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/yfs.${chr} \
    --chr ${chr} \
    --all_mod T"
done
```

***

```{r, eval=F, echo=T}
library(data.table)

# Read in pseudoval results
pseudo_res<-NULL
for(i in 1:22){
  pseudo_res<-rbind(pseudo_res, fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/yfs.',i)))
}

# Determine the best model based on TWAS.Z and observed cor, and rank methods by TWAS.Z and observed cor for each gene.
genes<-unique(pseudo_res$ID)
obs_pseudo_rank<-NULL
rank_diff<-NULL
n_top<-NULL
for(i in 1:length(genes)){
  obs_pseudo_i<-pseudo_res[pseudo_res$ID == genes[i],]
  obs_pseudo_i$pseudo_rank<-rank(-obs_pseudo_i$TWAS.Z)
  obs_pseudo_i$obs_rank<-rank(-obs_pseudo_i$MODELCV.R2)
  obs_pseudo_rank<-rbind(obs_pseudo_rank, obs_pseudo_i)
  
  rank_diff<-rbind(rank_diff, data.frame(ID=genes[i],
                                         pseudo_top_mod=obs_pseudo_i$MODEL[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank)][1],
                                         pseudo_R = sqrt(obs_pseudo_i$MODELCV.R2[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank)][1]),
                                         obs_top_mod=obs_pseudo_i$MODEL[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank)][1],
                                         top_R = sqrt(obs_pseudo_i$MODELCV.R2[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank)][1])))
  
}

# Calculate correlation between model rank for each gene
cor(obs_pseudo_rank$pseudo_rank, obs_pseudo_rank$obs_rank) # 0.06539382

# Calculate the mean difference in R between the best model and the model selected by TWAS.Z
rank_diff$diff<-rank_diff$pseudo_R-rank_diff$top_R
mean(rank_diff$diff, na.rm=T) # -0.02387192

# Calculate the percentage of genes where pseuodoval did not select the correct model
nrow(rank_diff[rank_diff$diff != 0,])/nrow(rank_diff) # 0.8240206

# Crosstab the selected observed and pseudoval-selected best model
saveRDS(table(rank_diff$pseudo_top_mod, rank_diff$obs_top_mod),'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/best_pseudo_comp.rds')
table(rank_diff$pseudo_top_mod, rank_diff$obs_top_mod)
table(rank_diff$pseudo_top_mod)
table(rank_diff$obs_top_mod)

rank_diff<-rank_diff[order(rank_diff$diff),]

library(ggplot2)
library(cowplot)

bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/best_pseudo_comp.png', res=300, units='px', width=1000, height=1000)
ggplot(rank_diff, aes(x=top_R, y=pseudo_R)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, colour='red') +
  coord_fixed() +
  theme_half_open() +
  background_grid() +
  labs(x="R (Best)", y="R (Pseudovalidated)")
dev.off()

bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/best_pseudo_comp_hist.png', res=300, units='px', width=1500, height=1000)
ggplot(rank_diff, aes(x=diff)) +
  geom_histogram() +
  theme_half_open() +
  background_grid() +
  labs(x="Difference in R")
dev.off()

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/pseudo_ldak_model_comp.png', res=300, units='px', width=3000, height=2000)ggplot(obs_pseudo_rank, aes(x=MODELCV.R2, y=TWAS.Z)) +
      geom_point() +
      geom_abline(intercept = 0, slope = 1, colour='red') +
      theme_half_open() +
      background_grid() +
      labs(x="R2 (Observed)", y="TWAS.Z") +
      facet_wrap(.~ MODEL)
dev.off()

```

</details>

<details><summary>Comparison of model that performed best in YFS to model that was selected by pseudovalidation</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/best_pseudo_comp.png){width=50%}

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/best_pseudo_comp_hist.png){width=50%}

```{r, eval=T, echo=F}

tmp<-readRDS('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/best_pseudo_comp.rds')

tmp<-tmp[dimnames(tmp)[[1]], dimnames(tmp)[[1]]]

library(caret) 
confusionMatrix(tmp)


```

The variance explained by the best model identified by pseudovalidation is very similar to the best model identified by cross validation, however the pseudoval model is often not the model identified by cross validation.

</details>

### YFS eQTL

```{bash, echo=T, eval=F}

conda activate eqtl_to_twas
for chr in $(seq 1 22); do
  sbatch -p neurohack_cpu,cpu -t 10 --mem 10G --wrap="
  Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/fusion_pseudoval.R \
    --sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt \
  	--weights /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos \
  	--weights_dir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL \
    --ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION//1000G.EUR. \
    --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/yfs.eqtl.${chr} \
    --chr ${chr} \
    --all_mod T"
done

```

```{r, eval=F, echo=T}
library(data.table)

# Read in pseudoval results
pseudo_res <- NULL
for (i in 1:22) {
  pseudo_res <-
    rbind(
      pseudo_res,
      fread(
        paste0(
          '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/fusion_pseudo/yfs.eqtl.', i
        )
      )
    )
}

cor_res_melt<-readRDS('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS_cor.rds')

eqtl_pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos')
w_dir<-'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/'
eqtl_sig<-NULL
for(i in 1:nrow(eqtl_pos)){
  load(paste0(w_dir, eqtl_pos$WGT[i]))
  eqtl_sig<-rbind(eqtl_sig,
                  data.frame(ID=eqtl_pos$ID[i],
                             hsq=hsq[1],
                             hsq.p=hsq.pv,
                             TopSNP_Pvalue=signal$TopSNP_Pvalue,
                             P_mBATcombo=signal$P_mBATcombo))
}

eqtl_sig_true<-eqtl_sig[eqtl_sig$TopSNP_Pvalue < 5e-8 | eqtl_sig$P_mBATcombo < 0.01,]
cor_res_melt_sig<-cor_res_melt[cor_res_melt$L1 %in% eqtl_sig_true$ID,]
cor_res_melt_enet<-cor_res_melt[cor_res_melt$Var1 == 'twas.enet',]
cor_res_melt_enet_neg<-cor_res_melt_enet[cor_res_melt_enet$value < -0.1, ]
cor_res_melt_enet_neg<-data.table(ID=cor_res_melt_enet_neg$L1,
                                  MODEL=gsub('eqtl.','',cor_res_melt_enet_neg$Var2),
                                  BAD = T)

pseudo_res_neg_all<-pseudo_res[pseudo_res$ID %in% cor_res_melt_enet_neg$ID,]
pseudo_res_neg_all<-merge(pseudo_res_neg_all, cor_res_melt_enet_neg, by=c('ID','MODEL'), all.x=T)

ggplot(pseudo_res_neg_all, aes(x=MODEL, y=TWAS.Z, colour=BAD)) +
  geom_point() +
  facet_wrap('ID') + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

# This indicates that fusion pseudoval does distinguish the models that don't correlated well with other models.
# Check this again when we have observed correlations in GTEx. 
# Removing models with a low correlation with other models might also be a good solution.
  
```


```{r, eval=F, echo=T}
library(data.table)

# Read in pseudoval results
pseudo_res_2<-NULL
for(i in 1:22){
  pseudo_res_2<-rbind(pseudo_res_2, fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/pseudo_res_chr',i)))
}

names(pseudo_res_2)[names(pseudo_res_2) == 'MODEL']<-'Model'
pseudo_res_2<-pseudo_res_2[,c('ID','Model','TWAS.Z'), with=F]

pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGenall/eQTLGen.eQTL.pos')
pos2<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/eQTLGen/eQTLGen.eQTL.pos')

pseudo_res<-NULL
for(i in 1:nrow(pos2)){
  for(mod in c('top1','sbayesr','sbayesr_robust','dbslmm','prscs','susie')){
    res_i_mod<-fread(paste0('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo/pseudo_res/', pos2$ID[i],'.',mod))
    
    pseudo_res<-rbind(pseudo_res, data.frame(ID=pos2$ID[i],
                                             Model=mod,
                                             TWAS.Z=res_i_mod$TWAS.Z))
  }
}

pseudo_comp<-merge(pseudo_res, pseudo_res_2, by=c('ID','Model'))
# New ad old pseudoval scripts correlate perfectly.

# Read in the correlation between predicted and observed expression in GTEx v8.
cor_res_melt_obs<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/GTEx_v8_pred_exp/pred_obs_cor.txt')

cor_res_melt_obs<-cor_res_melt_obs[,c('L1','Var2','value'),with=F]
names(cor_res_melt_obs)<-c('ID','Model','R')
cor_res_melt_obs$Model<-gsub('eQTL.','',cor_res_melt_obs$Model)

obs_pseudo<-merge(pseudo_res_2, cor_res_melt_obs, by=c('ID','Model'))

# Check whether median R of pseudoval models is greater than average across all models
obs_pseudo_top<-obs_pseudo[order(obs_pseudo$TWAS.Z),]
obs_pseudo_top<-obs_pseudo_top[!is.na(obs_pseudo_top$TWAS.Z),]
obs_pseudo_top<-obs_pseudo_top[!duplicated(obs_pseudo_top$ID),]
median(obs_pseudo_top$R, na.rm=T) # 0.02435701
median(obs_pseudo$R[obs_pseudo$Model == 'dbslmm'], na.rm=T)
median(obs_pseudo$R[obs_pseudo$Model == 'lassosum'], na.rm=T)
median(obs_pseudo$R[obs_pseudo$Model == 'ldpred2'], na.rm=T)
median(obs_pseudo$R[obs_pseudo$Model == 'prscs'], na.rm=T)
median(obs_pseudo$R[obs_pseudo$Model == 'sbayesr'], na.rm=T)
median(obs_pseudo$R[obs_pseudo$Model == 'sbayesr_robust'], na.rm=T) #0.04455735


# Determine the best model based on TWAS.Z and observed cor, and rank methods by TWAS.Z and observed cor for each gene.
genes<-unique(obs_pseudo$ID)
obs_pseudo_rank<-NULL
rank_diff<-NULL
n_top<-NULL
for(i in 1:length(genes)){
  obs_pseudo_i<-obs_pseudo[obs_pseudo$ID == genes[i],]
  obs_pseudo_i$pseudo_rank<-rank(-obs_pseudo_i$TWAS.Z)
  obs_pseudo_i$obs_rank<-rank(-obs_pseudo_i$R)
  obs_pseudo_rank<-rbind(obs_pseudo_rank, obs_pseudo_i)
  
  rank_diff<-rbind(rank_diff, data.frame(ID=genes[i],
                                         pseudo_top_mod=obs_pseudo_i$Model[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank)][1],
                                         pseudo_R = obs_pseudo_i$R[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank)][1],
                                         obs_top_mod=obs_pseudo_i$Model[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank)][1],
                                         top_R = obs_pseudo_i$R[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank)][1]))
  
}

# Calculate correlation between model rank for each gene
cor(obs_pseudo_rank$pseudo_rank, obs_pseudo_rank$obs_rank) # 0.09677969

# Calculate the mean difference in R between the best model and the model selected by TWAS.Z
rank_diff$diff<-rank_diff$pseudo_R-rank_diff$top_R
mean(rank_diff$diff, na.rm=T) # -0.02587632

# Calculate the percentage of genes where pseuodoval did not select the correct model
nrow(rank_diff[rank_diff$diff != 0,])/nrow(rank_diff) # 0.8447695

# Crosstab the selected observed and pseudoval-selected best model
saveRDS(table(rank_diff$pseudo_top_mod, rank_diff$obs_top_mod),'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/best_pseudo_comp_eQTLGen.rds')
table(rank_diff$pseudo_top_mod, rank_diff$obs_top_mod)
table(rank_diff$pseudo_top_mod)
table(rank_diff$obs_top_mod)

rank_diff<-rank_diff[order(rank_diff$diff),]

library(ggplot2)
library(cowplot)

bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/best_pseudo_comp_eQTLGen.png', res=300, units='px', width=1000, height=1000)
ggplot(rank_diff, aes(x=top_R, y=pseudo_R)) +
  geom_abline(intercept = 0, slope = 1, colour='red') +
  geom_point() +
  coord_fixed() +
  theme_half_open() +
  background_grid() +
  labs(x="R (Best)", y="R (Pseudovalidated)")
dev.off()

bitmap('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/best_pseudo_comp_eQTLGen_hist.png', res=300, units='px', width=1500, height=1000)
ggplot(rank_diff, aes(x=diff)) +
  geom_histogram() +
  theme_half_open() +
  background_grid() +
  labs(x="Difference in R")
dev.off()

```

</details>

<details><summary>Comparison of model that performed best in GTEx to model that was selected by pseudovalidation</summary>

![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/best_pseudo_comp_eQTLGen.png){width=50%}
![](/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/best_pseudo_comp_eQTLGen_hist.png){width=50%}

```{r, eval=T, echo=F}

tmp<-readRDS('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/pseudo2/best_pseudo_comp_eQTLGen.rds')

tmp<-tmp[dimnames(tmp)[[1]], dimnames(tmp)[[1]]]

library(caret) 
confusionMatrix(tmp)

```

</details>

***

## LDAK

***

### YFS FUSION

```{bash, echo=T, eval=F}
conda activate eqtl_to_twas
for chr in $(seq 1 22); do
  sbatch -p neurohack_cpu,cpu -t 10 --mem 10G --wrap="
  Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/ldak_pseudoval.R \
    --sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt \
    --weights /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION/YFS.BLOOD.RNAARR.pos \
    --weights_dir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/FUSION \
    --ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
    --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/yfs.${chr} \
    --chr ${chr} \
    --ldak /users/k1806347/oliverpainfel/Software/ldak5.1.linux"
done
```

```{r, eval=F, echo=T}
library(data.table)

# Read in pseudoval results
pseudo_res <- NULL
for (i in 1:22) {
  pseudo_res <-
    rbind(
      pseudo_res,
      fread(
        paste0(
          '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/yfs.',i,'.pseudo_cor.txt'
        )
      )
    )
}

# Read in reported correlation
obs_res <- NULL
for (i in 1:22) {
  obs_res <-
    rbind(
      obs_res,
      fread(
        paste0(
          '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/yfs.',i,'.obs_cor.txt'
        )
      )
    )
}

pseudo_res<-merge(pseudo_res, obs_res, by=c('MODEL','ID'))
pseudo_res<-pseudo_res[complete.cases(pseudo_res),]

# Determine the best model based on pseudoval cor and observed cor, and rank methods by pseudoval and observed cor for each gene.
genes<-unique(pseudo_res$ID)
obs_pseudo_rank<-NULL
rank_diff<-NULL
n_top<-NULL
for(i in 1:length(genes)){
  obs_pseudo_i<-pseudo_res[pseudo_res$ID == genes[i],]
  obs_pseudo_i$pseudo_rank<-rank(-obs_pseudo_i$R.x)
  obs_pseudo_i$obs_rank<-rank(-obs_pseudo_i$R.y)
  obs_pseudo_rank<-rbind(obs_pseudo_rank, obs_pseudo_i)
  
  rank_diff<-rbind(rank_diff, data.frame(ID=genes[i],
                                         pseudo_top_mod=obs_pseudo_i$MODEL[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank)][1],
                                         pseudo_R = obs_pseudo_i$R.y[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank)][1],
                                         obs_top_mod=obs_pseudo_i$MODEL[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank)][1],
                                         top_R = obs_pseudo_i$R.y[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank)][1]))
  
}

# Calculate correlation between model rank for each gene
cor(obs_pseudo_rank$pseudo_rank, obs_pseudo_rank$obs_rank) # 0.02060233

# Calculate the mean difference in R between the best model and the model selected by TWAS.Z
rank_diff$diff<-rank_diff$pseudo_R-rank_diff$top_R
mean(rank_diff$diff, na.rm=T) # -0.02445525

# Calculate the percentage of genes where pseuodoval did not select the correct model
nrow(rank_diff[rank_diff$diff != 0,])/nrow(rank_diff) # 0.8957225

# Crosstab the selected observed and pseudoval-selected best model
saveRDS(table(rank_diff$pseudo_top_mod, rank_diff$obs_top_mod),'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/best_pseudo_ldak_comp.rds')
table(rank_diff$pseudo_top_mod, rank_diff$obs_top_mod)
table(rank_diff$pseudo_top_mod)
table(rank_diff$obs_top_mod)

rank_diff<-rank_diff[order(rank_diff$diff),]

library(ggplot2)
library(cowplot)

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/best_pseudo_ldak_comp.png', res=300, units='px', width=1000, height=1000)
ggplot(rank_diff, aes(x=top_R, y=pseudo_R)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, colour='red') +
  coord_fixed() +
  theme_half_open() +
  background_grid() +
  labs(x="R (Best)", y="R (Pseudovalidated)")
dev.off()

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/best_pseudo_ldak_comp_hist.png', res=300, units='px', width=1500, height=1000)
ggplot(rank_diff, aes(x=diff)) +
  geom_histogram() +
  theme_half_open() +
  background_grid() +
  labs(x="Difference in R")
dev.off()

lim<-c(
  min(c(sign(obs_pseudo_rank$R.x)*abs(obs_pseudo_rank$R.y), obs_pseudo_rank$R), na.rm=T),
  max(c(sign(obs_pseudo_rank$R.x)*abs(obs_pseudo_rank$R.y), obs_pseudo_rank$R), na.rm=T)
)

plot_list<-list()
for(i in unique(obs_pseudo_rank$MODEL)){
  plot_list[[i]]<-ggplot(obs_pseudo_rank[obs_pseudo_rank$MODEL == i], aes(x=R.y, y=R.x)) +
      geom_point() +
      geom_abline(intercept = 0, slope = 1, colour='red') +
      theme_half_open() +
      background_grid() +
      xlim(lim) +
      ylim(lim) +
      coord_fixed() +
      labs(x="R (Observed)", y="R (Pseudovalidated)", title=i)
}

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/pseudo_ldak_model_comp.png', res=300, units='px', width=3000, height=2000)
plot_grid(plotlist = plot_list)
dev.off()

# Pseudoval results are biased towards certain methods, and it seems to over estimate poor models, and underestimate good models

# Can we account for the bias?
summary(lm(obs_pseudo_rank$R.x - obs_pseudo_rank$R.y ~ obs_pseudo_rank$MODEL)) # Big differences in average R
obs_pseudo_rank$R_resid<-as.numeric(resid(lm(obs_pseudo_rank$R.x ~ obs_pseudo_rank$MODEL)))

genes<-unique(pseudo_res$ID)
obs_pseudo_resid_rank<-NULL
rank_diff_resid<-NULL
n_top<-NULL
for(i in 1:length(genes)){
  obs_pseudo_i<-obs_pseudo_rank[obs_pseudo_rank$ID == genes[i],]
  obs_pseudo_i$pseudo_rank<-rank(-obs_pseudo_i$R_resid)
  obs_pseudo_i$obs_rank<-rank(-obs_pseudo_i$R.y)
  obs_pseudo_resid_rank<-rbind(obs_pseudo_resid_rank, obs_pseudo_i)
  
  rank_diff_resid<-rbind(rank_diff_resid, data.frame(ID=genes[i],
                                         pseudo_top_mod=obs_pseudo_i$MODEL[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank,na.rm=T)][1],
                                         pseudo_R = obs_pseudo_i$R.y[obs_pseudo_i$pseudo_rank == min(obs_pseudo_i$pseudo_rank,na.rm=T)][1],
                                         obs_top_mod=obs_pseudo_i$MODEL[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank,na.rm=T)][1],
                                         top_R = obs_pseudo_i$R.y[obs_pseudo_i$obs_rank == min(obs_pseudo_i$obs_rank,na.rm=T)][1]))
  
}

# Calculate correlation between model rank for each gene
cor(obs_pseudo_resid_rank$pseudo_rank, obs_pseudo_resid_rank$obs_rank) # 0.183464

# Calculate the mean difference in R between the best model and the model selected by pseudoval
rank_diff_resid$diff<-rank_diff_resid$pseudo_R-rank_diff_resid$top_R
mean(rank_diff_resid$diff, na.rm=T) # -0.01549056

# Calculate the percentage of genes where pseuodoval did not select the correct model
nrow(rank_diff_resid[rank_diff_resid$diff != 0,])/nrow(rank_diff_resid) # 0.7265376

# Crosstab the selected observed and pseudoval-selected best model
saveRDS(table(rank_diff_resid$pseudo_top_mod, rank_diff_resid$obs_top_mod),'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/best_pseudo_ldak_comp_resid.rds')
table(rank_diff_resid$pseudo_top_mod, rank_diff_resid$obs_top_mod)
table(rank_diff_resid$pseudo_top_mod)
table(rank_diff_resid$obs_top_mod)

rank_diff_resid<-rank_diff_resid[order(rank_diff_resid$diff),]

library(ggplot2)
library(cowplot)

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/best_pseudo_ldak_comp_resid.png', res=300, units='px', width=1000, height=1000)
ggplot(rank_diff_resid, aes(x=top_R, y=pseudo_R)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, colour='red') +
  coord_fixed() +
  theme_half_open() +
  background_grid() +
  labs(x="R (Best)", y="R (Pseudovalidated)")
dev.off()

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/best_pseudo_ldak_comp_resid_hist.png', res=300, units='px', width=1500, height=1000)
ggplot(rank_diff_resid, aes(x=diff)) +
  geom_histogram() +
  theme_half_open() +
  background_grid() +
  labs(x="Difference in R")
dev.off()

lim<-c(
  min(c(sign(obs_pseudo_rank$R_resid)*abs(obs_pseudo_rank$R.y), obs_pseudo_rank$R), na.rm=T),
  max(c(sign(obs_pseudo_rank$R_resid)*abs(obs_pseudo_rank$R.y), obs_pseudo_rank$R), na.rm=T)
)

plot_list<-list()
for(i in unique(obs_pseudo_rank$MODEL)){
  plot_list[[i]]<-ggplot(obs_pseudo_rank[obs_pseudo_rank$MODEL == i], aes(x=R.y, y=R_resid)) +
      geom_point() +
      geom_abline(intercept = 0, slope = 1, colour='red') +
      theme_half_open() +
      background_grid() +
      xlim(lim) +
      ylim(lim) +
      coord_fixed() +
      labs(x="R (Observed)", y="R (Pseudovalidated - residual)", title=i)
}

png('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/pseudo_ldak_model_comp_resid.png', res=300, units='px', width=3000, height=2000)
plot_grid(plotlist = plot_list)
dev.off()

# This correction helps a bit, but not much.

```

***

### YFS eQTL

```{bash, echo=T, eval=F}
conda activate eqtl_to_twas
for chr in $(seq 1 22); do
  sbatch -p neurohack_cpu,cpu -t 10 --mem 10G --wrap="
  Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/ldak_pseudoval.R \
    --sumstats /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/YFS_eQTL_from_fusion.txt \
  	--weights /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos \
  	--weights_dir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL \
  	--ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
    --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/yfs.eqtl.${chr} \
    --chr ${chr} \
    --ldak /users/k1806347/oliverpainfel/Software/ldak5.1.linux"
done

mkdir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/eqtl

```

```{r, eval=F, echo=T}
library(data.table)

# Read in pseudoval results
pseudo_res <- NULL
for (i in 1:22) {
  pseudo_res <-
    rbind(
      pseudo_res,
      fread(
        paste0(
          '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/ldak_pseudo/yfs.eqtl.',i,'.pseudo_cor.txt'
        )
      )
    )
}

cor_res_melt<-readRDS('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/1kg_pred_exp/YFS_cor.rds')

eqtl_pos<-fread('/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/YFS.eQTL.pos')
w_dir<-'/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/YFS/eQTL/'
eqtl_sig<-NULL
for(i in 1:nrow(eqtl_pos)){
  load(paste0(w_dir, eqtl_pos$WGT[i]))
  eqtl_sig<-rbind(eqtl_sig,
                  data.frame(ID=eqtl_pos$ID[i],
                             hsq=hsq[1],
                             hsq.p=hsq.pv,
                             TopSNP_Pvalue=signal$TopSNP_Pvalue,
                             P_mBATcombo=signal$P_mBATcombo))
}

eqtl_sig_true<-eqtl_sig[eqtl_sig$TopSNP_Pvalue < 5e-8 | eqtl_sig$P_mBATcombo < 0.01,]
cor_res_melt_sig<-cor_res_melt[cor_res_melt$L1 %in% eqtl_sig_true$ID,]
cor_res_melt_enet<-cor_res_melt[cor_res_melt$Var1 == 'twas.enet',]
cor_res_melt_enet_neg<-cor_res_melt_enet[cor_res_melt_enet$value < -0.1, ]
cor_res_melt_enet_neg<-data.table(ID=cor_res_melt_enet_neg$L1,
                                  MODEL=gsub('eqtl.','',cor_res_melt_enet_neg$Var2),
                                  BAD = T)

pseudo_res_neg_all<-pseudo_res[pseudo_res$ID %in% cor_res_melt_enet_neg$ID,]
pseudo_res_neg_all<-merge(pseudo_res_neg_all, cor_res_melt_enet_neg, by=c('ID','MODEL'), all.x=T)

ggplot(pseudo_res_neg_all, aes(x=MODEL, y=R, colour=BAD)) +
  geom_point() +
  facet_wrap('ID') + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

# This indicates that ldak pseudoval does distinguish the models that don't correlated well with other models.
# Check this again when we have observed correlations in GTEx. 
# Removing models with a low correlation with other models might also be a good solution.
  
```

***

# OTTERS

## Install

```{bash}
# Install OTTERS v1.0.0
cd /users/k1806347/oliverpainfel/Software
git clone https://github.com/daiqile96/OTTERS.git 
cd OTTERS
git checkout v1.0.0

# Install tabix and bgzip
cd /users/k1806347/oliverpainfel/Software
wget https://sourceforge.net/projects/samtools/files/tabix/tabix-0.2.6.tar.bz2
tar jxvf tabix-0.2.6.tar.bz2
cd tabix-0.2.6
make

# copy the binary bgzip and tabix bin folder so can be called from PATH
mkdir /users/k1806347/oliverpainfel/Software/bin
cp bgzip tabix /users/k1806347/oliverpainfel/Software/bin

# copy the plink1.9 binary and add to PATH
cp /users/k1806347/oliverpainfel/Software/plink1.9/plink /users/k1806347/oliverpainfel/Software/bin/
export PATH=/users/k1806347/oliverpainfel/Software/bin:$PATH 

# Create a conda environment to run otters
cd /users/k1806347/oliverpainfel/Software/OTTERS
mamba env create --file otters_env.yaml
conda activate otters

# Install lassosum
Rscript -e 'remotes::install_github("tshmak/lassosum@v0.4.5")'

# Install SDPR
cd /users/k1806347/oliverpainfel/Software/bin
git clone https://github.com/eldronzhou/SDPR.git
cd SDPR
git checkout v0.9.1
```

***

## Run test data

```{bash}
# Run using test data
conda activate otters

# set number of threads to be used
N_THREADS=1

# set up my OTTERS directory and SDPR directory
OTTERS_DIR=/users/k1806347/oliverpainfel/Software/OTTERS
SDPR_DIR=/users/k1806347/oliverpainfel/Software/bin/SDPR

# make sure the dynamic libraries of SDPR are not changed (For SDPR)
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${SDPR_DIR}/MKL/lib
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${SDPR_DIR}/gsl/lib

# prevent automatically using  all available cores on a compute node (For SDPR and PRS-CS)
export MKL_NUM_THREADS=$N_THREADS
export NUMEXPR_NUM_THREADS=$N_THREADS
export OMP_NUM_THREADS=$N_THREADS

# Start to run OTTERS
cd ${OTTERS_DIR}/Example

# Input for OTTERS STAGE I 
# Annotation File 
exp_anno=exp_anno.txt
# Genotype data from LD reference panel
geno_dir=Exp_geno
# eQTL summary statistics 
sst_file=Exp_eQTLSumStats.txt
# Input for OTTERS STAGE II
# GWAS summary statistics 
gwas_sst_file=Exp_GWASSumStats.txt

# Set chromosome number (The example is for chromosome 4)
chr=4
# Set LD-clumping threshold in STAGE I
clump_r2=0.99
# Set output directory for STAGE I
out_dir=Results

# STAGE I
# train eQTL weights using P+T, lassosum, SDPR and PRS-CS. 
# It may take several minutes to complete.
python3 ${OTTERS_DIR}/training.py \
--OTTERS_dir=${OTTERS_DIR} \
--SDPR_dir=${SDPR_DIR} \
--anno_dir=${exp_anno} \
--geno_dir=${geno_dir} \
--sst_file=${sst_file} \
--out_dir=${out_dir} \
--chrom=${chr} \
--r2=${clump_r2} \
--models=PT,lassosum,SDPR,PRScs \
--thread=$N_THREADS

# It has completed with the test data
# Do a speed and memory benchmark for 100 genes from YFS eQTL data
```

***

## Replicate paper

***

### Download eQTLGen weights

```{bash}
# Download the eQTLGen weights and results in the OTTERS paper: https://www.synapse.org/#!Synapse:syn51009573/files/
mkdir -p /users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen
cd /users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen
```

```{python}
import shutil
import os
from synapseclient import Synapse

# Read in auth_token
with open('/users/k1806347/oliverpainfel/Data/synapse/auth_token.txt', 'r') as file:
    content = file.read()

# Initialize the Synapse client and log in
syn = Synapse()
syn.login(authToken=content)

# List of Synapse IDs you want to download and move
syn_ids = [
    'syn51015448',
    'syn51015449',
    'syn51015450',
    'syn51015456',
    'syn51015458',
    'syn51015464'
]

# Define the new directory where you want to store the files
new_directory = '/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen'

for syn_id in syn_ids:
    # Download the file from Synapse
    entity = syn.get(entity=syn_id, version=1)
    
    # Get the original path and filename
    original_path = entity.path
    filename = os.path.basename(original_path)
    
    # Construct the new path in the desired directory with the same filename
    new_path = os.path.join(new_directory, filename)
    
    # Move the file
    shutil.move(original_path, new_path)
    
    print(f"Moved {filename} to {new_path}")
    
    
```

```{bash}
# Decompress the eQTLGen weights
cd /users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen 

gunzip lassosum.txt.gz
gunzip OTTERS_TWAS_SumStat_CARDIOVASCULAR_UKBB.txt
gunzip P0.001.txt.gz
gunzip P0.05.txt.gz
gunzip PRScs.txt.gz
gunzip SDPR.txt.gz

# Note the weights appear to be GRCh38
# We need to liftover the reference genotype data and GWAS sumstats
```

***

## Prepare input files

```{r}
# Create annotation file using re
library(data.table)
res<-fread('/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/OTTERS_TWAS_SumStat_CARDIOVASCULAR_UKBB.txt')
annot<-res[, c('CHROM','GeneStart','GeneEnd','TargetID'), with=F]
fwrite(annot, '/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/annot.txt', sep='\t', quote=F, na='NA')
```

```{bash}
# Download and format the GWAS sumstats
cd /users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen
wget https://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/GCST90029001-GCST90030000/GCST90029019/GCST90029019_buildGRCh37.tsv
```

```{r}
library(data.table)
library(GenoUtils)
ss<-fread('/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/GCST90029019_buildGRCh37.tsv')
ss<-ss[, c('chromosome','base_pair_location','effect_allele','other_allele','beta','standard_error'), with=F]
names(ss)<-c('CHROM','POS','A1','A2','BETA','SE')

ss_matched<-NULL
target_build<-'GRCh38'
for(i in 1:22){
  ss_i<-ss[ss$CHROM == i,]
  ref_i<-readRDS(paste0('/users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',i,'.rds'))
  names(ref_i)<-paste0('REF.',names(ref_i))
  ss_i$IUPAC<-snp_iupac(ss_i$A1, ss_i$A2)

  # Merge target and reference by BP
  ref_target<-merge(ss_i, ref_i, by.x='POS', by.y='REF.BP_GRCh37')
  
  # Identify targ-ref strand flips, and flip target
  flip_logical<-detect_strand_flip(targ = ref_target$IUPAC, ref = ref_target$REF.IUPAC)

  flipped<-ref_target[flip_logical,]
  flipped$A1<-snp_allele_comp(flipped$A1)
  flipped$A2<-snp_allele_comp(flipped$A2)      
  flipped$IUPAC<-snp_iupac(flipped$A1, flipped$A2)
  
  # Identify SNPs that have matched IUPAC
  matched<-ref_target[ref_target$IUPAC == ref_target$REF.IUPAC,]
  matched<-rbind(matched, flipped)
  
  matched<-matched[, c('CHROM','REF.BP_GRCh38','A1','A2','BETA','SE'), with=F]
  names(matched)<-c('CHROM','POS','A1','A2','BETA','SE')
  ss_matched<-rbind(ss_matched, matched)
}

ss_matched$Zscore<-ss_matched$BETA/ss_matched$SE
ss_matched<-ss_matched[, c('CHROM','POS','A1','A2','Zscore'), with=F]
ss_matched<-ss_matched[complete.cases(ss_matched),]
fwrite(ss_matched, '/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/GCST90029019_buildGRCh38.reformat.tsv', quote=F, sep='\t', na='NA')
```

```{bash}
mkdir -p /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh37
cd /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh37
for chr in $(seq 1 22);do
for file in $(echo bim bed fam rds); do
cp /users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr${chr}.${file} ./
done
done
```

```{r}
# Create version of reference data in GRCh38
for(i in 1:22){
  bim<-fread(paste0('/users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr', i,'.bim'))
  names(bim)<-c('CHR','SNP','POS','BP','A1','A2')
  snp_ref<-readRDS(paste0('/users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',i,'.rds'))
  names(snp_ref)<-paste0('REF.',names(snp_ref))
  bim_new<-merge(bim, snp_ref, by.x='SNP', by.y='REF.SNP')
  bim_new<-bim_new[!is.na(bim_new$REF.BP_GRCh38),]
  bim_new<-bim_new[order(bim_new$REF.BP_GRCh38),]
  
  write.table(bim_new$SNP, paste0('/users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/chr',i,'.extract'), col.names=F, row.names=F, quote=F)
  
  write.table(bim_new[, c('SNP', 'REF.BP_GRCh38'), with=F], paste0('/users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/chr',i,'.remap'), col.names=F, row.names=F, quote=F)

  system(paste0('/users/k1806347/oliverpainfel/Software/plink2 --bfile /users/k1806347/oliverpainfel/Software/MyGit/GenoDisc/pipeline/resources/data/1kg/1KG.Phase3.EUR.MAF_001.chr',i,' --extract /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/chr',i,'.extract --update-map /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/chr',i,'.remap --sort-vars --make-pgen --out /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/1KG.Phase3.EUR.MAF_001.chr',i))
  system(paste0('/users/k1806347/oliverpainfel/Software/plink2 --pfile /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/1KG.Phase3.EUR.MAF_001.chr',i,' --make-bed --out /users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/1KG.Phase3.EUR.MAF_001.chr',i))
}
```

***

### Run OTTERS

```{bash}
conda activate otters
# set number of threads to be used
N_THREADS=1

# set up my OTTERS directory and SDPR directory
OTTERS_DIR=/users/k1806347/oliverpainfel/Software/OTTERS
SDPR_DIR=/users/k1806347/oliverpainfel/Software/bin/SDPR

# Input for OTTERS STAGE I 
# Annotation File 
exp_anno=/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/annot.txt

# Input for OTTERS STAGE II
# GWAS summary statistics 
gwas_sst_file=/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/GCST90029019_buildGRCh38.reformat.tsv

for model in $(echo P0.001 P0.05 lassosum SDPR PRScs); do
for chr in $(seq 1 21); do
  sbatch -p neurohack_cpu,cpu -t120 --mem 10G --wrap="

# make sure the dynamic libraries of SDPR are not changed (For SDPR)
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${SDPR_DIR}/MKL/lib
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${SDPR_DIR}/gsl/lib
export PATH=/users/k1806347/oliverpainfel/Software/bin:$PATH 

# prevent automatically using  all available cores on a compute node (For SDPR and PRS-CS)
export MKL_NUM_THREADS=$N_THREADS
export NUMEXPR_NUM_THREADS=$N_THREADS
export OMP_NUM_THREADS=$N_THREADS

# STAGE II
# gene-based association test using eQTL-weight trained from P+T, lassosum, SDPR and PRS-CS.
mkdir -p /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/OTTERS/chr${chr}/${model}
python3 ${OTTERS_DIR}/testing.py \
  --OTTERS_dir=${OTTERS_DIR} \
  --weight_dir=/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen \
  --models=${model} \
  --anno_dir=${exp_anno} \
  --geno_dir=/users/k1806347/oliverpainfel/Data/1KG/GenoDisc/GRCh38/1KG.Phase3.EUR.MAF_001.chr${chr} \
  --out_dir=/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/OTTERS/chr${chr}/${model} \
  --gwas_file=${gwas_sst_file} \
  --chrom=${chr} \
  --thread=$N_THREADS
"
done
done

```

***

### Compare with original results

```{r}
library(data.table)

# Read in results
res <- NULL
for (j in c('P0.001', 'P0.05', 'lassosum', 'SDPR', 'PRScs')) {
  for (i in 22:22) {
    tmp <- fread(
        paste0(
          '/users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/OTTERS/chr',
          i,
          '/',
          j,
          '/',
          j,
          '.txt'
        )
      )
  }
  tmp$MODEL<-j
  tmp <- tmp[, c('TargetID', 'MODEL', 'FUSION_PVAL'), with = F]
  res <- rbind(res, tmp)
}

# Perform ACAT.O analysis
ACATO <- function(p){
    if (all(is.na(p))) return(NA)
    p <- p[!is.na(p)]
    p[p == 1] <- 1 - 1e-16
#### check if there are very small non-zero p values
    is.small <- (p < 1e-16)
    if (sum(is.small) == 0) {
        cct.stat <- sum(tan((0.5 - p) * pi))/length(p)
    } else {
        cct.stat <- sum((1 / p[is.small]) / pi)
        cct.stat <- cct.stat + sum(tan((0.5 - p[!is.small]) * pi))
        cct.stat <- cct.stat/length(p)
    }
    #### check if the test statistic is very large.
    if (cct.stat > 1e+15){
        pval <- (1 / cct.stat) / pi
    } else {
        pval <- 1 - pcauchy(cct.stat)
    }
    pval
}

res_acat<-data.table(aggregate(res$FUSION_PVAL, list(res$TargetID), FUN=ACATO))
names(res_acat)<-c('TargetID', 'OTTERS')

library(reshape2)
res_wide <- dcast(res, TargetID ~ MODEL, value.var = "FUSION_PVAL")
res_wide<-merge(res_wide, res_acat, by = 'TargetID')

# Read in original results
orig<-fread('/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/OTTERS_TWAS_SumStat_CARDIOVASCULAR_UKBB.txt')
orig<-orig[, names(res_wide), with=F]
both<-merge(orig, res_wide, by='TargetID')

# Convert to Z scores, and check correlations between each test
both_z<-apply(both[,-1], 2, function(x) qnorm(x))
cor(both_z, use='p')
table(is.na(both_z))

# There are missing values in the original results which are not missing in the replication
# For those that are present, the correlation is <1, probably due to missing SNPs and different LD reference.
```

Limitations of OTTERS:
- Slow
- Requires consistent builds across files (not RSID based)
- Not restricted to HapMap3
- Format doesn't integrate well with existing downstream TWAS methodology

***

### Compare to eQTL_to_TWAS

Run TWAS using eQTLGen weights I generated and the same sumstats as the OTTERS paper.

```{bash}
# Download eQTLGen weights
cd /users/k1806347/oliverpainfel/Data/eQTLGen/eQTL_to_TWAS
wget -O eQTLGen.eQTL.tar.gz https://zenodo.org/records/7068381/files/eQTLGen.eQTL.tar.gz?download=1
wget -O eQTLGen.eQTL.pos https://zenodo.org/records/7068381/files/eQTLGen.eQTL.pos?download=1

tar -xvzf eQTLGen.eQTL.tar.gz
rm eQTLGen.eQTL.tar.gz
```

```{r}
library(data.table)

# Munge the sumstats
ss<-fread('/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/GCST90029019_buildGRCh37.tsv')
ss$z_score<-ss$beta/ss$standard_error
ss<-ss[, c('variant_id','effect_allele','other_allele','z_score'), with=F]
names(ss)<-c('SNP','A1','A2','Z')
fwrite(ss, '/users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/GCST90029019_buildGRCh37.munged.tsv.gz', quote=F, sep='\t', na='NA')
```

```{bash}
# Run FUSION
mkdir /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/OTTERS/eQTL_to_TWAS
conda activate eqtl_to_twas
for chr in $(seq 22 22); do
    sbatch -p neurohack_cpu,cpu -t120 --mem 10G --wrap="
    Rscript /users/k1806347/oliverpainfel/Software/MyGit/eQTL_to_TWAS/FUSION.assoc_test.edit.R \
    --sumstats /users/k1806347/oliverpainfel/Data/OTTERS/eQTLGen/GCST90029019_buildGRCh37.munged.tsv.gz \
    --weights /users/k1806347/oliverpainfel/Data/eQTLGen/eQTL_to_TWAS/eQTLGen.eQTL.pos \
    --weights_dir /users/k1806347/oliverpainfel/Data/eQTLGen/eQTL_to_TWAS \
    --ref_ld_chr /users/k1806347/oliverpainfel/Data/1KG/FUSION/1000G.EUR. \
    --out /users/k1806347/oliverpainfel/Analyses/eQTL_to_TWAS/data/OTTERS/eQTL_to_TWAS/GCST90029019.eQTLGen.chr${chr} \
    --chr ${chr} \
    --GWASN 459324
    "
done

load('/users/k1806347/oliverpainfel/Data/eQTLGen/eQTL_to_TWAS/eQTLGen.eQTL/ENSG00000244486.RDat')
```
```

